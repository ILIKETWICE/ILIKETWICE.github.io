<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title> TCP 超时与重传  | 权掌天下</title><meta name="keywords" content="Nginx"><meta name="author" content="LIKE-YCY"><meta name="copyright" content="LIKE-YCY"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="我们都知道 TCP 协议具有重传机制，也就是说，如果发送方认为发生了丢包现象，就重发这些数据包。很显然，我们需要一个方法来「猜测」是否发生了丢包。最简单的想法就是，接收方每收到一个包，就向发送方返回一个 ACK，表示自己已经收到了这段数据，反过来，如果发送方一段时间内没有收到 ACK，就知道很可能是数据包丢失了，紧接着就重发该数据包，直到收到 ACK 为止。 你可能注意到我用的是「猜测」，因为即使">
<meta property="og:type" content="article">
<meta property="og:title" content=" TCP 超时与重传 ">
<meta property="og:url" content="https://like-ycy.github.io/2019/12/31/2019-12-31-tcp-timeout-and-retransmission/index.html">
<meta property="og:site_name" content="权掌天下">
<meta property="og:description" content="我们都知道 TCP 协议具有重传机制，也就是说，如果发送方认为发生了丢包现象，就重发这些数据包。很显然，我们需要一个方法来「猜测」是否发生了丢包。最简单的想法就是，接收方每收到一个包，就向发送方返回一个 ACK，表示自己已经收到了这段数据，反过来，如果发送方一段时间内没有收到 ACK，就知道很可能是数据包丢失了，紧接着就重发该数据包，直到收到 ACK 为止。 你可能注意到我用的是「猜测」，因为即使">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-4.png">
<meta property="article:published_time" content="2019-12-30T16:00:00.000Z">
<meta property="article:modified_time" content="2021-12-10T01:15:43.317Z">
<meta property="article:author" content="LIKE-YCY">
<meta property="article:tag" content="Nginx">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-4.png"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://like-ycy.github.io/2019/12/31/2019-12-31-tcp-timeout-and-retransmission/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":180,"position":"top","messagePrev":"注意：这篇文章距离上次更新已有","messageNext":"天了，文章的内容可能已过时。"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: ' TCP 超时与重传 ',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-10 09:15:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom@v1.css"><link rel="stylesheet" href="/css/color@v1.css"><meta name="generator" content="Hexo 6.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "/img/loading.gif" data-lazy-src="/img/favicon.ico" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-4.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">权掌天下</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title"> TCP 超时与重传 </h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-12-30T16:00:00.000Z" title="发表于 2019-12-31 00:00:00">2019-12-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-10T01:15:43.317Z" title="更新于 2021-12-10 09:15:43">2021-12-10</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">2.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>9分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=" TCP 超时与重传 "><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>我们都知道 TCP 协议具有重传机制，也就是说，如果发送方认为发生了丢包现象，就重发这些数据包。很显然，我们需要一个方法来「<strong>猜测</strong>」是否发生了丢包。最简单的想法就是，接收方每收到一个包，就向发送方返回一个 <strong>ACK</strong>，表示自己已经收到了这段数据，反过来，如果发送方一段时间内没有收到 ACK，就知道<strong>很可能</strong>是数据包丢失了，紧接着就重发该数据包，直到收到 ACK 为止。</p>
<p>你可能注意到我用的是「猜测」，因为即使是超时了，这个数据包也可能并没有丢，它只是绕了一条远路，来的很晚而已。毕竟 TCP 协议是位于<strong>传输层</strong>的协议，不可能明确知道数据链路层和物理层发生了什么。但这并不妨碍我们的超时重传机制，因为接收方会自动忽略重复的包。</p>
<p>超时和重传的概念其实就是这么简单，但内部的细节却是很多，我们最先想到的一个问题就是，<strong>到底多长时间才能算超时呢</strong>？</p>
<h2 id="超时是怎么确定的？"><a href="#超时是怎么确定的？" class="headerlink" title="超时是怎么确定的？"></a>超时是怎么确定的？</h2><p>一刀切的办法就是，我<strong>直接把超时时间设成一个固定值</strong>，比如说 200ms，但这样肯定是有问题的，我们的电脑和很多服务器都有交互，这些服务器位于天南海北，国内国外，延迟差异巨大，打个比方：</p>
<ul>
<li>我的个人博客搭在国内，延迟大概 30ms，也就是说正常情况下的数据包，60ms 左右就已经能收到 ACK 了，但是按照我们的方法，200ms 才能确定丢包（正常可能是 90 到 120 ms），这<strong>效率实在是有点低</strong>。</li>
<li>假设你访问某国外网站，延迟有 130 ms，这就麻烦了，<strong>正常的数据包都可能被认为是超时，导致大量数据包被重发，可以想象，重发的数据包也很容易被误判为超时。。。雪崩效应的感觉</strong></li>
</ul>
<p>所以设置固定值是很不可靠的，<strong>我们要根据网络延迟，动态调整超时时间</strong>，延迟越大，超时时间越长。</p>
<p>在这里先引入两个概念：</p>
<ul>
<li>RTT（Round Trip Time）：往返时延，也就是<strong>数据包从发出去到收到对应 ACK 的时间。</strong>RTT 是针对连接的，每一个连接都有各自独立的 RTT。</li>
<li>RTO（Retransmission Time Out）：重传超时，也就是前面说的超时时间。</li>
</ul>
<p>比较标准的 RTT 定义：</p>
<blockquote>
<p>Measure the elapsed time between sending a data octet with a particular sequence number and <strong>receiving an acknowledgment that covers that sequence number</strong> (segments sent do not have to match segments received). This measured elapsed time is the Round Trip Time (RTT).</p>
</blockquote>
<h3 id="经典方法"><a href="#经典方法" class="headerlink" title="经典方法"></a>经典方法</h3><p>最初的规范「RFC0793」采用了下面的公式来得到平滑的 RTT 估计值（称作 SRTT）：</p>
<p><strong>SRTT  &lt;-  α·SRTT +（1 - α）·RTT</strong></p>
<p>RTT 是指最新的样本值，这种估算方法叫做「指数加权移动平均」，名字听起来比较高大上，但整个公式比较好理解，就是利用现存的 SRTT 值和最新测量到的 RTT 值取一个加权平均。</p>
<p>有了 SRTT，就该设置对应的 RTO 的值了，「RFC0793」是这么算的：</p>
<p><strong>RTO = min(ubound, max(lbound, (SRTT)·β))</strong></p>
<p>这里面的 <strong>ubound</strong> 是 RTO 的<strong>上边界</strong>，<strong>lbound</strong> 为 RTO 的<strong>下边界</strong>，β 称为<strong>时延离散因子</strong>，推荐值为 1.3 ~ 2.0。这个计算公式就是将  (SRTT)·β 的值作为 RTO，只不过另外<strong>限制了 RTO 的上下限</strong>。</p>
<p>这个计算方法，初看是没有什么问题（至少我是这么感觉的），但是实际应用起来，有两个缺陷：</p>
<blockquote>
<p>There were two known problems with the RTO calculations specified in RFC-793. First, the accurate measurement of RTTs is difficult <strong>when there are retransmissions</strong>. Second, the algorithm to compute the smoothed round-trip time is inadequate [TCP:7], <strong>because it incorrectly assumed that the variance in RTT values would be small and constant</strong>. These problems were solved by <strong>Karn’s and Jacobson’s algorithm</strong>, respectively.</p>
</blockquote>
<p>这段话摘自「RFC1122」，我来解释一下：</p>
<ul>
<li>当<strong>出现数据包重传的情况</strong>下，RTT 的计算就会很“麻烦”，我画了张图来说明这些情况：</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/like-ycy/images/raw/master/blog/2019-12-31/rtt.png"></p>
<ul>
<li><p>图上列了两种情况，这两种情况下计算 RTT 的方法是不一样的（这就是所谓的重传二义性）：</p>
<p>但是对于客户端来说，它不知道发生了哪种情况，选错情况的结果就是 RTT 偏大/偏小，影响到 RTO 的计算。（最简单粗暴的解决方法就是<strong>忽略有重传的数据包，只计算那些没重传过的</strong>，但这样会导致其他问题。。详见 Karn’s algorithm）</p>
</li>
<li><ul>
<li>情况一：RTT = t2 - t0</li>
<li>情况二：RTT = t2 - t1</li>
</ul>
</li>
<li><p>另一个问题是，<strong>这个算法假设 RTT 波动比较小</strong>，因为这个加权平均的算法又叫<strong>低通滤波器</strong>，对突然的网络波动不敏感。如果网络时延突然增大导致实际 RTT 值远大于估计值，会导致不必要的重传，增大网络负担。（ RTT 增大已经表明网络出现了过载，这些不必要的重传会进一步加重网络负担）。</p>
</li>
</ul>
<h3 id="标准方法"><a href="#标准方法" class="headerlink" title="标准方法"></a>标准方法</h3><p>说实话这个标准方法比较，，，麻烦，我就直接贴公式了：</p>
<p><strong>SRTT  &lt;-  (1 - α)·SRTT  + α·RTT</strong>  //跟基本方法一样，<strong>求 SRTT 的加权平均</strong></p>
<p><strong>rttvar  &lt;- (1 - h)·rttvar + h·(|RTT - SRTT |)</strong>  //计算 <strong>SRTT 与真实值的差距</strong>（称之为绝对误差|Err|），同样用到<strong>加权平均</strong></p>
<p><strong>RTO = SRTT  + 4·rttvar</strong> //估算出来的新的 RTO，rttvar 的系数 4 是调参调出来的</p>
<p>这个算法的整体思想就是结合<strong>平均值</strong>（就是基本方法）和<strong>平均偏差</strong>来进行估算，一波玄学调参得到不错的效果。如果想更深入了解这个算法，参考「RFC6298」。</p>
<h2 id="重传——TCP的重要事件"><a href="#重传——TCP的重要事件" class="headerlink" title="重传——TCP的重要事件"></a>重传——TCP的重要事件</h2><h3 id="基于计时器的重传"><a href="#基于计时器的重传" class="headerlink" title="基于计时器的重传"></a>基于计时器的重传</h3><p>这种机制下，<strong>每个数据包都有相应的计时器</strong>，一旦超过 RTO 而没有收到 ACK，就重发该数据包。没收到 ACK 的数据包都会存在重传缓冲区里，等到 ACK 后，就从缓冲区里删除。</p>
<p>首先明确一点，对 TCP 来说，超时重传是<strong>相当重要</strong>的事件（RTO 往往大于两倍的 RTT，超时往往意味着拥塞），一旦发生这种情况，<strong>TCP 不仅会重传对应数据段，还会降低当前的数据发送速率</strong>，因为TCP 会认为当前网络发生了拥塞。</p>
<p>简单的超时重传机制往往比较低效，如下面这种情况：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/like-ycy/images/raw/master/blog/2019-12-31/transfer.png"></p>
<p>假设数据包5丢失，数据包 6,7,8,9 都已经到达接收方，这个时候客户端就只能等服务器发送 ACK，注意对于包 6,7,8,9，服务器都不能发送 ACK，这是滑动窗口机制决定的，因此对于客户端来说，他完全不知道丢了几个包，可能就悲观的认为，5 后面的数据包也都丢了，就重传这 5 个数据包，这就比较浪费了。</p>
<h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p>快速重传机制「RFC5681」基于接收端的反馈信息来引发重传，而非重传计时器超时。</p>
<p>刚刚提到过，基于计时器的重传往往要等待很长时间，而快速重传使用了很巧妙的方法来解决这个问题：<strong>服务器如果收到乱序的包，也给客户端回复 ACK</strong>，只不过是重复的 ACK。就拿刚刚的例子来说，收到乱序的包 6,7,8,9 时，服务器全都发 ACK = 5。这样，客户端就知道 5 发生了空缺。一般来说，如果客户端连续三次收到重复的 ACK，就会重传对应包，而不需要等到计时器超时。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/like-ycy/images/raw/master/blog/2019-12-31/fast-transfer.png"></p>
<p>但快速重传仍然没有解决第二个问题：到底该重传多少个包？</p>
<h3 id="带选择确认的重传"><a href="#带选择确认的重传" class="headerlink" title="带选择确认的重传"></a>带选择确认的重传</h3><p>改进的方法就是 SACK（Selective Acknowledgment），简单来讲就是在快速重传的基础上，<strong>返回最近收到的报文段的序列号范围</strong>，这样客户端就知道，哪些数据包已经到达服务器了。</p>
<p>来几个简单的示例：</p>
<ul>
<li><p>case 1：第一个包丢失，剩下的 7 个包都被收到了。</p>
<p>当收到 7 个包的<strong>任何一个</strong>的时候，接收方会返回一个带 SACK 选项的 ACK，告知发送方自己收到了哪些乱序包。注：<strong>Left Edge，Right Edge 就是这些乱序包的左右边界</strong>。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Triggering    ACK      Left Edge   Right Edge</span><br><span class="line">Segment</span><br><span class="line"></span><br><span class="line">5000         (lost)</span><br><span class="line">5500         5000     5500       6000</span><br><span class="line">6000         5000     5500       6500</span><br><span class="line">6500         5000     5500       7000</span><br><span class="line">7000         5000     5500       7500</span><br><span class="line">7500         5000     5500       8000</span><br><span class="line">8000         5000     5500       8500</span><br><span class="line">8500         5000     5500       9000</span><br></pre></td></tr></table></figure>

<ul>
<li><p>case 2：第 2, 4, 6, 8 个数据包丢失。</p>
</li>
<li><ul>
<li>收到第一个包时，没有乱序的情况，正常回复 ACK。</li>
<li>收到第 3, 5, 7 个包时，由于出现了乱序包，回复带 SACK 的 ACK。</li>
<li>因为这种情况下有很多碎片段，所以相应的 Block 段也有很多组，当然，因为选项字段大小限制， Block 也有上限。</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Triggering  ACK    First Block   2nd Block     3rd Block</span><br><span class="line">Segment            Left   Right  Left   Right  Left   Right</span><br><span class="line">                   Edge   Edge   Edge   Edge   Edge   Edge</span><br><span class="line"></span><br><span class="line">5000       5500</span><br><span class="line">5500       (lost)</span><br><span class="line">6000       5500    6000   6500</span><br><span class="line">6500       (lost)</span><br><span class="line">7000       5500    7000   7500   6000   6500</span><br><span class="line">7500       (lost)</span><br><span class="line">8000       5500    8000   8500   7000   7500   6000   6500</span><br><span class="line">8500       (lost)</span><br></pre></td></tr></table></figure>

<p>不过 SACK 的规范「RFC2018」有点坑爹，接收方可能会在提供一个 SACK 告诉发送方这些信息后，又「食言」，也就是说，接收方可能把这些（乱序的）数据包删除掉，然后再通知发送方。以下摘自「RFC2018」：</p>
<blockquote>
<p>Note that the data receiver is permitted to discard data in its queue that has not been acknowledged to the data sender, even if the data has already been reported in a SACK option. <strong>Such discarding of SACKed packets is discouraged, but may be used if the receiver runs out of buffer space.</strong></p>
</blockquote>
<p>最后一句是说，<strong>当接收方缓冲区快被耗尽时</strong>，可以采取这种措施，当然并不建议这种行为。。。</p>
<p>由于这个操作，发送方在收到 SACK 以后，也不能直接清空重传缓冲区里的数据，一直到接收方发送普通的，ACK 号大于其最大序列号的值的时候才能清除。另外，重传计时器也收到影响，重传计时器应该忽略 SACK 的影响，毕竟接收方把数据删了跟丢包没啥区别。</p>
<h3 id="DSACK-扩展"><a href="#DSACK-扩展" class="headerlink" title="DSACK 扩展"></a>DSACK 扩展</h3><p>DSACK，即重复 SACK，这个机制是在 SACK 的基础上，额外携带信息，<strong>告知发送方有哪些数据包自己重复接收了</strong>。DSACK 的目的是帮助发送方判断，是否发生了包失序、ACK 丢失、包重复或伪重传。让 TCP 可以更好的做网络流控。</p>
<p>关于 DSACK，「RFC2883」里举了很多例子，有兴趣的读者可以去阅读一下，我这里就不讲那么细了。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">LIKE-YCY</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://like-ycy.github.io/2019/12/31/2019-12-31-tcp-timeout-and-retransmission/">https://like-ycy.github.io/2019/12/31/2019-12-31-tcp-timeout-and-retransmission/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://like-ycy.github.io" target="_blank">权掌天下</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Nginx/">Nginx</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-4.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/01/01/2020-01-01-mesos-pull-images-error/"><img class="prev-cover" src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-8.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"> mesos 以容器方式启动,拉取镜像失败问题 </div></div></a></div><div class="next-post pull-right"><a href="/2019/12/30/2019-12-30-tcp-handshake/"><img class="next-cover" src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-6.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"> TCP 协议，握手挥手不是你想的那么简单 </div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/07/20/2020-07-20-nginx-logs/" title=" Nginx日志配置详解 "><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/background/header-background.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-12-10</div><div class="title"> Nginx日志配置详解 </div></div></a></div><div><a href="/2019/12/12/2019-12-12-nginx-chinese/" title="Nginx 配置参数中文说明 "><img class="cover" src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-2.png" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-12-10</div><div class="title">Nginx 配置参数中文说明 </div></div></a></div><div><a href="/2019/12/19/2019-12-19-nginx-usage/" title=" Nginx的这些妙用，你肯定有不知道的 "><img class="cover" src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-8.png" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-12-10</div><div class="title"> Nginx的这些妙用，你肯定有不知道的 </div></div></a></div><div><a href="/2019/12/22/2019-12-22-nginx-principle/" title=" Nginx 原理和架构 "><img class="cover" src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-2.png" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-12-10</div><div class="title"> Nginx 原理和架构 </div></div></a></div><div><a href="/2019/12/26/2019-12-26-nginx-reload/" title=" Nginx 中 reload 流程 "><img class="cover" src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-3.png" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-12-10</div><div class="title"> Nginx 中 reload 流程 </div></div></a></div><div><a href="/2020/05/26/2020-05-26-nginx-config-location-proxypass/" title=" Nginx配置location中proxy_pass的'/'号的作用 "><img class="cover" src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-10.png" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-12-10</div><div class="title"> Nginx配置location中proxy_pass的'/'号的作用 </div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "/img/loading.gif" data-lazy-src="/img/favicon.ico" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">LIKE-YCY</div><div class="author-info__description">权掌天下的博客</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/like-ycy/"><i class="fab fa-github"></i><span>Follow Me Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/like-ycy" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E6%98%AF%E6%80%8E%E4%B9%88%E7%A1%AE%E5%AE%9A%E7%9A%84%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">超时是怎么确定的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">经典方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">标准方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E4%BC%A0%E2%80%94%E2%80%94TCP%E7%9A%84%E9%87%8D%E8%A6%81%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.</span> <span class="toc-text">重传——TCP的重要事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%AE%A1%E6%97%B6%E5%99%A8%E7%9A%84%E9%87%8D%E4%BC%A0"><span class="toc-number">2.1.</span> <span class="toc-text">基于计时器的重传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0"><span class="toc-number">2.2.</span> <span class="toc-text">快速重传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E9%80%89%E6%8B%A9%E7%A1%AE%E8%AE%A4%E7%9A%84%E9%87%8D%E4%BC%A0"><span class="toc-number">2.3.</span> <span class="toc-text">带选择确认的重传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DSACK-%E6%89%A9%E5%B1%95"><span class="toc-number">2.4.</span> <span class="toc-text">DSACK 扩展</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/02/06/2022-02-06-githubactions-pull-images/" title="无法拉取 gcr.io 镜像？用魔法来打败魔法"><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无法拉取 gcr.io 镜像？用魔法来打败魔法"/></a><div class="content"><a class="title" href="/2022/02/06/2022-02-06-githubactions-pull-images/" title="无法拉取 gcr.io 镜像？用魔法来打败魔法">无法拉取 gcr.io 镜像？用魔法来打败魔法</a><time datetime="2022-02-05T16:00:00.000Z" title="发表于 2022-02-06 00:00:00">2022-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/23/2021-12-23-k8s-gitlabci-layer/" title=" Gitlab CI 在 Kubernetes 中的 Docker 缓存 "><img src= "/img/loading.gif" data-lazy-src="/img/background/header-background.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt=" Gitlab CI 在 Kubernetes 中的 Docker 缓存 "/></a><div class="content"><a class="title" href="/2021/12/23/2021-12-23-k8s-gitlabci-layer/" title=" Gitlab CI 在 Kubernetes 中的 Docker 缓存 "> Gitlab CI 在 Kubernetes 中的 Docker 缓存 </a><time datetime="2021-12-22T16:00:00.000Z" title="发表于 2021-12-23 00:00:00">2021-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/23/2021-12-23-python-underline-rules/" title=" Python下划线的5个潜规则 "><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-7.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt=" Python下划线的5个潜规则 "/></a><div class="content"><a class="title" href="/2021/12/23/2021-12-23-python-underline-rules/" title=" Python下划线的5个潜规则 "> Python下划线的5个潜规则 </a><time datetime="2021-12-22T16:00:00.000Z" title="发表于 2021-12-23 00:00:00">2021-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/09/2021-12-09-linux-history/" title=" Linux History命令及其配置 "><img src= "/img/loading.gif" data-lazy-src="/img/background/header-background.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt=" Linux History命令及其配置 "/></a><div class="content"><a class="title" href="/2021/12/09/2021-12-09-linux-history/" title=" Linux History命令及其配置 "> Linux History命令及其配置 </a><time datetime="2021-12-08T16:00:00.000Z" title="发表于 2021-12-09 00:00:00">2021-12-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/08/2021-11-08-redis-acl/" title=" Redis 访问控制列表(ACL) "><img src= "/img/loading.gif" data-lazy-src="/img/background/header-background.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt=" Redis 访问控制列表(ACL) "/></a><div class="content"><a class="title" href="/2021/11/08/2021-11-08-redis-acl/" title=" Redis 访问控制列表(ACL) "> Redis 访问控制列表(ACL) </a><time datetime="2021-11-08T11:40:00.000Z" title="发表于 2021-11-08 19:40:00">2021-11-08</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-4.png')"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2022 By LIKE-YCY</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://like-ycy.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>