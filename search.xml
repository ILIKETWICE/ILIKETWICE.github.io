<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title>无法拉取 gcr.io 镜像？用魔法来打败魔法</title>
      <link href="/2022/02/06/2022-02-06-githubactions-pull-images/"/>
      <url>/2022/02/06/2022-02-06-githubactions-pull-images/</url>
      
        <content type="html"><![CDATA[<p>目前常用的 Docker Registry 公开服务有：</p><ul><li><code>docker.io</code> ：Docker Hub 官方镜像仓库，也是 Docker 默认的仓库</li><li><code>gcr.io</code>、<code>k8s.gcr.io</code> ：谷歌镜像仓库</li><li><code>quay.io</code> ：Red Hat 镜像仓库</li><li><code>ghcr.io</code> ：GitHub 镜像仓库</li></ul><p>当使用 <code>docker pull 仓库地址/用户名/仓库名:标签</code> 时，会前往对应的仓库地址拉取镜像，标签无声明时默认为 <code>latest</code>， 仓库地址无声明时默认为 <code>docker.io</code> 。</p><p>众所周知的原因，在国内访问这些服务异常的慢，甚至 <code>gcr.io</code> 和 <code>quay.io</code> 根本无法访问。</p><h2 id="解决方案：镜像加速器"><a href="#解决方案：镜像加速器" class="headerlink" title="解决方案：镜像加速器"></a>解决方案：镜像加速器</h2><p>针对 <code>Docker Hub</code> ，Docker 官方和国内各大云服务商均提供了 Docker 镜像加速服务。</p><p>你只需要简单配置一下（以 Linux 为例）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;镜像加速器&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo service docker restart</span><br></pre></td></tr></table></figure><p>便可以通过访问国内镜像加速器来加速 <code>Docker Hub</code> 的镜像下载。</p><p>!&gt; 不过这种办法也只能针对 <code>docker.io</code> ，其它的仓库地址并没有真正实际可用的加速器（至少我目前没找到）。</p><h2 id="解决方案：用魔法打败魔法"><a href="#解决方案：用魔法打败魔法" class="headerlink" title="解决方案：用魔法打败魔法"></a>解决方案：用魔法打败魔法</h2><p>既然无法治本，那治治标还是可以的吧。</p><p>若我们使用一台魔法机器从 <code>gcr.io</code> 或 <code>quay.io</code> 等仓库先把我们无法下载的镜像拉取下来，然后重新上传到 <code>docker.io</code> ，是不是就可以使用 <code>Docker Hub</code> 的镜像加速器来下载了。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本篇的实现已放在 GitHub ：**<code>https://github.com/togettoyou/hub-mirror</code>**</p>]]></content>
      
      
      <categories>
          
          <category> Github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gitlab CI 在 Kubernetes 中的 Docker 缓存</title>
      <link href="/2021/12/23/2021-12-23-k8s-gitlabci-layer/"/>
      <url>/2021/12/23/2021-12-23-k8s-gitlabci-layer/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Gitlab Runner的执行器有8个，常见的有Shell、Dcoker和Kubernetes。</p><p>Shell执行器配置简单，但是构建工具都需要手动安装，例如：JDK、Maven、Nodejs。如果此时有需求需要升级所有Shell执行器的JDK版本，还需要重新手动升级？(虽然可以写个脚本)</p><p>Docker和Kubernetes执行器比较灵活，缺点就是Docker执行器和Kubenetes执行器每次启动的容器或者Pod依赖包都是干净的，就需要重新拉取相关依赖包，比较耽误构建时间。</p><p>此时Shell执行器就比较占优势，因为是使用系统本机的构建工具，会在系统上留有构建缓存，例如：.mvn</p><p>那么怎么做，也能缓存Docker执行器的layer层呢？</p><p>这个问题的解决方法非常简单，与其为每个 Pod 运行一个 Docker DIND 服务的 sidecar 容器，不如让我们运行一个独立的 Docker DIND 容器，构建容器的所有 Docker CLI 都连接到这个一个 Docker 守护进程上，这个时候我们将 Docker layer 层进行持久化，也就起到了缓存的作用了。</p><h2 id="Docker-镜像说明"><a href="#Docker-镜像说明" class="headerlink" title="Docker 镜像说明"></a>Docker 镜像说明</h2><p>查看<a href="https://link.juejin.cn/?target=https://hub.docker.com/_/docker">官方的 docker 镜像</a></p><h3 id="docker-latest"><a href="#docker-latest" class="headerlink" title="docker:latest"></a>docker:latest</h3><p>该镜像只包含 Docker 客户端，需要有 Docker daemon 支持，可以使用 <code>docker:dind</code> 的，也可以挂载宿主机的 <code>/var/run/docker.sock</code>。</p><p>该镜像启动不需要 <code>--privileged</code> 参数。</p><h3 id="docker-dind"><a href="#docker-dind" class="headerlink" title="docker:dind"></a>docker:dind</h3><p>该镜像包含 Docker 客户端（命令行工具）和 Docker daemon。</p><p>通过 <code>docker history docker:dind</code> 命令我们发现 <code>docker:dind</code> 是在 <code>docker:latest</code> 基础上又安装了 Docker daemon</p><p>启动 <code>docker:dind</code> 容器时，参数 <code>--privileged</code> 必须加上，否则 Docker daemon 启动时会报错。</p><h2 id="正文开始"><a href="#正文开始" class="headerlink" title="正文开始"></a>正文开始</h2><p>首先创建一个 PVC 来存储 Docker 的持久化数据，为了性能考虑，这里我们使用的是一个 Local PV：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">local-volume</span></span><br><span class="line"><span class="attr">provisioner:</span> <span class="string">kubernetes.io/no-provisioner</span></span><br><span class="line"><span class="attr">reclaimPolicy:</span> <span class="string">Delete</span></span><br><span class="line"><span class="attr">volumeBindingMode:</span> <span class="string">WaitForFirstConsumer</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">docker-pv</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">5Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">local-volume</span></span><br><span class="line">  <span class="attr">local:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/mnt/k8s/docker</span>  <span class="comment"># 数据存储的目录</span></span><br><span class="line">  <span class="attr">nodeAffinity:</span></span><br><span class="line">    <span class="attr">required:</span></span><br><span class="line">      <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">          <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">          <span class="attr">values:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">node1</span>  <span class="comment"># 运行在node1节点</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">docker-dind</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">docker-dind-data</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-ops</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">local-volume</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">5Gi</span></span><br></pre></td></tr></table></figure><p>然后使用 Deployment 部署一个 Docker DIND 服务：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">docker-dind</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-ops</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">docker-dind</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">docker-dind</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">docker-dind</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">docker:dind</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">docker-dind</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--registry-mirror=https://ot2k4d59.mirror.aliyuncs.com/</span>  <span class="comment"># 指定一个镜像加速器地址</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">DOCKER_DRIVER</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">overlay2</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">DOCKER_HOST</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">tcp://0.0.0.0:2375</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">DOCKER_TLS_CERTDIR</span>   <span class="comment"># 禁用 TLS</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">docker-dind-data-vol</span> <span class="comment"># 持久化docker根目录</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/var/lib/docker/</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">daemon-port</span></span><br><span class="line">              <span class="attr">containerPort:</span> <span class="number">2375</span></span><br><span class="line">          <span class="attr">securityContext:</span></span><br><span class="line">            <span class="attr">privileged:</span> <span class="literal">true</span> <span class="comment"># 需要设置成特权模式</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">docker-dind-data-vol</span></span><br><span class="line">          <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">            <span class="attr">claimName:</span> <span class="string">docker-dind-data</span></span><br></pre></td></tr></table></figure><p>然后创建一个 Service 以方便构建的 Docker CLI 与其连接：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">docker-dind</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-ops</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">docker-dind</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">2375</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">2375</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">docker-dind</span></span><br></pre></td></tr></table></figure><p>将 Docker DIND 服务部署完成后，我们就可以在 Gitlab CI 中使用这个守护程序来构建镜像了，如下所示：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">image</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build_image:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">image</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">docker:latest</span></span><br><span class="line">  <span class="attr">variables:</span></span><br><span class="line">    <span class="attr">DOCKER_HOST:</span> <span class="string">tcp://docker-dind:2375</span>  <span class="comment"># 通过 service dns 形式连接 docker dind 服务</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span> <span class="string">info</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span> <span class="string">build</span> <span class="string">-t</span> <span class="string">xxxx</span> <span class="string">.</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span> <span class="string">push</span> <span class="string">xxxx</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">tags</span></span><br></pre></td></tr></table></figure><p>由于我们缓存了 Docker layer 层，这个时候构建的速度会明显提升。最后随着镜像的大量构建会产生很多镜像数据，我们可以写一个 Cronjob 用来定时清除缓存：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">docker-dind-clear-cache</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-ops</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="number">0</span> <span class="number">0</span> <span class="string">*</span> <span class="string">*</span> <span class="number">0</span>  <span class="comment"># 每周清理一次</span></span><br><span class="line">  <span class="attr">jobTemplate:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">docker-dind</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">docker-dind-clear-cache</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span></span><br><span class="line">          <span class="attr">containers:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">clear-cache</span></span><br><span class="line">              <span class="attr">image:</span> <span class="string">docker:latest</span></span><br><span class="line">              <span class="attr">command:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">docker</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">system</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">prune</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">-af</span></span><br><span class="line">              <span class="attr">env:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">DOCKER_HOST</span></span><br><span class="line">                  <span class="attr">value:</span> <span class="string">tcp://docker-dind:2375</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CI/CD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Kubernetes </tag>
            
            <tag> CI/CD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 访问控制列表(ACL)</title>
      <link href="/2021/11/08/2021-11-08-redis-acl/"/>
      <url>/2021/11/08/2021-11-08-redis-acl/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在 Redis6.0 之前的版本中，登陆 Redis Server 只需要输入密码（前提配置了密码 requirepass ）即可，不需要输入用户名，而且密码也是明文配置到配置文件中，安全性不高。并且应用连接也使用该密码，导致应用有所有权限处理数据，风险也极高。在 Redis6.0 有了 <a href="https://redis.io/topics/acl">ACL</a> 之后，终于解决了这些不安全的因素，可以按照不同的需求设置相关的用户和权限。本文来介绍下 Redis 6.0 ACL 相关的配置和使用。具体的说明可以查看官方文档：**<a href="https://redis.io/topics/acl">ACL</a>** </p><h2 id="ACL介绍"><a href="#ACL介绍" class="headerlink" title="ACL介绍"></a>ACL介绍</h2><p>Redis ACL 是 Access Control List 的缩写，是一种特性，它可以限制某些连接的<strong>可执行命令</strong>和<strong>访问 key</strong> 的权限。它的工作方式是，在连接之后，客户端需要提供用户名和有效密码进行身份验证：如果身份验证阶段成功，则连接与给定用户相关联，并限制用户的权限。Redis 可以配置为已经使用 <strong>“default”</strong> 用户（这是默认配置）对新连接进行了身份验证，所以配置 <strong>default</strong> 的用户，作为一个副作用，仅提供一个特定功能的子集，没有明确身份验证的连接。</p><p>在默认配置下 ，Redis 6（第一个拥有 ACL 的版本）的工作原理与旧版本的 Redis 完全相同，也就是说，每一个新的连接都能够调用每一个可能的命令和访问每一个 key ，所以ACL功能是向后兼容的。另外，使用requirepass配置指令配置密码的旧方法仍然可以正常工作，但现在它所做的只是为default用户设置密码。</p><p>Redis <a href="https://redis.io/commands/auth">AUTH</a>命令在 Redis 6 中被扩展了，所以它现在可以在两个参数的形式使用它：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AUTH &lt;username&gt; &lt;password&gt;</span><br></pre></td></tr></table></figure><p>按旧形式使用时，即：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AUTH &lt;password&gt;</span><br></pre></td></tr></table></figure><p>实际情况是，用于身份验证的用户名是“default”，因此仅指定密码就意味着我们要针对默认用户进行身份验证。这提供了与过去完美的向后兼容性。</p><h2 id="ACL的作用"><a href="#ACL的作用" class="headerlink" title="ACL的作用"></a>ACL的作用</h2><p>在使用acl之前，您可能想问问自己，通过实现这一层保护，您希望实现什么目标。通常acl可以很好地实现两个主要目标:</p><ul><li><p>限制对命令和密钥的访问来：</p><p>以便不受信任的客户机没有访问权限，而受信任的客户机只有对数据库的最低访问级别，以便执行所需的工作。例如，某些客户端只能执行只读命令。</p></li><li><p>提高操作安全性：</p><p>以防止由于软件错误或人为错误而导致进程或人员访问 Redis，从而破坏数据或配置。例如，从Redis获取延迟作业的worker没有理由能够调用FLUSHALL命令。</p></li></ul><h2 id="ACL-规则"><a href="#ACL-规则" class="headerlink" title="ACL 规则"></a>ACL 规则</h2><p>以下是有效的ACL规则列表。某些规则只是单个单词，用于激活或删除标志，或执行对用户ACL的给定更改。其他规则是与命令或类别名称或键模式等连接的字符前缀。</p><h4 id="启用和禁用用户"><a href="#启用和禁用用户" class="headerlink" title="启用和禁用用户"></a>启用和禁用用户</h4><p><code>on</code>：启用用户，可以使用该用户进行身份验证。</p><p><code>off</code>：禁用用户，不再可能与该用户进行身份验证，但是已经通过身份验证的连接仍将工作。</p><p>注意，如果默认用户被标记为关闭，新的连接开始时将不经过身份验证，并且将要求用户发送带有AUTH选项的AUTH或HELLO以某种方式进行身份验证，而不管默认用户配置如何。</p><h4 id="允许和禁止命令"><a href="#允许和禁止命令" class="headerlink" title="允许和禁止命令"></a>允许和禁止命令</h4><p><code>+&lt;command&gt;</code>：将该命令添加到用户可以调用的命令列表中。可以与<code>|</code>一起使用以允许子命令(例如“+config|get”)。</p><p><code>—&lt;command&gt;</code>：将命令从用户可以调用的命令列表中移除。可以与<code>|</code>一起用于阻塞子命令(例如“-config|set”)。</p><p><code>+@&lt;category&gt;</code>：为用户添加一类命令的权限，有效的类如@admin， @set， @sortedset，…等等，通过调用ACL CAT命令查看完整的列表。特殊类别@all表示所有命令，包括当前在服务器中存在的命令和将来将通过模块加载的命令。</p><p><code>-@&lt;category&gt;</code>：类似**+@&lt;category&gt;**，从客户端可以调用的命令列表中删除命令</p><p><code>+\&lt;command&gt;|first-arg</code>：允许一个特定的第一个参数，否则禁用命令。注意，这个表单不允许是负数，比如-SELECT|1，而只能是以“+”开头的加法。</p><p><code>allcommands</code>：+@all的别名。注意，它意味着能够执行通过模块系统加载的所有未来命令。</p><p><code>nocommands</code>： -@all的别名。</p><h4 id="允许和禁止某些-key"><a href="#允许和禁止某些-key" class="headerlink" title="允许和禁止某些 key"></a>允许和禁止某些 key</h4><p><code>~&lt;pattern&gt;</code>：添加可以作为命令的一部分提到的键模式。例如~*允许所有的键。该模式是一个全局样式的模式，类似于KEYS模式。可以指定多个模式。</p><p><code>allkeys</code>:  也就是~*。</p><p><code>resetkeys</code>：刷新允许的键模式列表。例如ACL ~foo:* ~bar:* resetkeys ~objects:*，将导致客户端只能访问匹配模式对象:*的键。</p><h4 id="允许和禁止发布-订阅频道"><a href="#允许和禁止发布-订阅频道" class="headerlink" title="允许和禁止发布/订阅频道"></a>允许和禁止发布/订阅频道</h4><p><code>&amp;&lt;pattern&gt;</code>：添加一个用户可以访问的发布/订阅通道的glob样式模式。可以指定多个通道模式。注意，模式匹配只对PUBLISH和SUBSCRIBE提到的通道进行，而PSUBSCRIBE要求在其通道模式和用户允许的通道模式之间进行文字匹配。</p><p><code>allchannels</code>：&amp;*别名，允许用户访问所有发布/订阅通道</p><p><code>resetchannels</code>：刷新允许的通道模式列表，如果用户的发布/订阅客户端不再能够访问各自的通道和/或通道模式，则断开这些客户端。</p><h4 id="为用户配置有效的密码"><a href="#为用户配置有效的密码" class="headerlink" title="为用户配置有效的密码"></a>为用户配置有效的密码</h4><p><code>&gt;&lt;password&gt;</code>：将此密码添加到用户的有效密码列表中。例如，&gt;mypass将把“mypass”添加到有效密码列表中。该指令清除nopass标志(参见后面的内容)。每个用户可以有任意数量的密码。</p><p><code>&lt;&lt;password&gt;</code>：从有效密码列表中删除此密码。如果删除的密码实际上没有设置，则将发出错误。</p><p><code>#&lt;hash&gt;</code>：将此SHA-256哈希值添加到该用户的有效密码列表中。此hash值将与为ACL用户输入的密码的hash值进行比较。这允许用户将hash值存储在acl.conf文件中，而不是存储明文密码。只能接受SHA-256哈希值，因为密码hash值必须为64个字符，且只能包含小写的十六进制字符。</p><p><code>!&lt;hash&gt;</code>：从有效密码列表中删除此hash值。当您不知道由hash值指定的密码，但希望从用户中删除密码时，这是非常有用的。</p><p><code>nopass</code>：用户设置的所有密码都被删除，用户被标记为不需要密码:这意味着每个密码都适用于该用户。如果将此指令用于默认用户，则每个新连接都将立即使用默认用户进行身份验证，而不需要任何显式的AUTH命令。注意，resetpass指令将清除这个条件。</p><p><code>resetpass</code>：清除允许的密码列表。此外，还删除了nopass状态。重置后，用户没有相关的密码，如果不添加一些密码(或稍后设置为nopass)，就无法进行身份验证。</p><h4 id="重置用户"><a href="#重置用户" class="headerlink" title="重置用户"></a>重置用户</h4><p><code>rest</code>：执行以下操作:resetpass, resetkeys, resetchannels, off， -@all。用户在创建后立即返回到相同的状态。</p><h2 id="使用-ACL-命令配置-ACL"><a href="#使用-ACL-命令配置-ACL" class="headerlink" title="使用 ACL 命令配置 ACL"></a>使用 ACL 命令配置 ACL</h2><p>acl是使用DSL(领域特定语言)定义的，DSL描述了给定用户能够做什么或不能做什么。这样的规则总是从第一个到最后一个，从左到右实现，因为有时规则的顺序对理解用户真正能够做什么很重要。</p><p>首先看 ACL 的 help，了解大致的使用方法：ACL help</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; ACL <span class="built_in">help</span></span><br><span class="line"> 1) ACL &lt;subcommand&gt; arg arg ... arg. Subcommands are:</span><br><span class="line"> 2) LOAD                             -- 从ACL文件中重新载入用户信息.</span><br><span class="line"> 3) SAVE                             -- 保存当前的用户配置信息到ACL文件.</span><br><span class="line"> 4) LIST                             -- 以配置文件格式显示用户详细信息.</span><br><span class="line"> 5) USERS                            -- 列出所有注册的用户名.</span><br><span class="line"> 6) SETUSER &lt;username&gt; [attribs ...] -- 创建或则修改一个用户.</span><br><span class="line"> 7) GETUSER &lt;username&gt;               -- 得到一个用户的详细信息.</span><br><span class="line"> 8) DELUSER &lt;username&gt; [...]         -- 删除列表中的用户.</span><br><span class="line"> 9) CAT                              -- 列出可用的类别.</span><br><span class="line">10) CAT &lt;category&gt;                   -- 列出指定类别中的命令.</span><br><span class="line">11) GENPASS [&lt;bits&gt;]                 -- 生成一个安全的用户密码.</span><br><span class="line">12) WHOAMI                           -- 返回当前的连接用户.</span><br><span class="line">13) LOG [&lt;count&gt; | RESET]            -- 显示ACL日志条目.</span><br></pre></td></tr></table></figure><p>默认情况下，redis只定义了一个用户，称为<strong>default</strong>。</p><p>我们可以使用<strong>ACL LIST</strong>命令来检查当前启用的ACL，并验证一个刚启动的、默认配置的Redis实例的配置是什么:</p><p>默认 default 用户，没有配置密码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; acl list</span><br><span class="line">1) <span class="string">&quot;user default on nopass ~* &amp;* +@all&quot;</span></span><br></pre></td></tr></table></figure><p>配置密码的：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; acl list</span><br><span class="line">1) <span class="string">&quot;user onlyread on #ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad ~* +@all&quot;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参 数</th><th>说明</th></tr></thead><tbody><tr><td>user</td><td>用户</td></tr><tr><td>default</td><td>表示默认用户名，或则自己定义的用户名</td></tr><tr><td>on</td><td>表示是否启用该用户，默认为 off（禁用）</td></tr><tr><td>#…</td><td>表示用户密码，nopass 表示不需要密码</td></tr><tr><td>~*</td><td>表示可以访问的 Key（正则匹配）</td></tr><tr><td>&amp;*</td><td>Pub/Sub通道(发布/订阅)</td></tr><tr><td>+@</td><td>表示用户的权限，+/- 表示授权还是销权； @为权限类。+@all 表示所有权限</td></tr></tbody></table><p>权限对 key 的类型和命令的类型进行了分类，如有对数据类型进行分类：string、hash、list、set、sortedset，和对命令类型进行分类：connection、admin、dangerous。</p><h2 id="配置实例"><a href="#配置实例" class="headerlink" title="配置实例"></a>配置实例</h2><h4 id="密码相关"><a href="#密码相关" class="headerlink" title="密码相关"></a>密码相关</h4><p>1、配置密码：一个用户可以设置不同的密码，即一个用户可以有多个密码。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 添加密码 </span><br><span class="line">## &gt;开头: &gt;password，明文密码；</span><br><span class="line">&gt; ACL SETUSER zhoujy on &gt;abc</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"># 获取哈希值密码 echo -n &quot;cba&quot; | shasum -a 256</span><br><span class="line">6d970874d0db767a7058798973f22cf6589601edab57996312f2ef7b56e5584d</span><br><span class="line"></span><br><span class="line">## #开头: #hash，SHA-256哈希值</span><br><span class="line">&gt; ACL SETUSER zhoujy on #6d970874d0db767a7058798973f22cf6589601edab57996312f2ef7b56e5584d</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">## 查看</span><br><span class="line">&gt; ACL GETUSER zhoujy</span><br><span class="line">1) &quot;flags&quot;</span><br><span class="line">2) 1) &quot;on&quot;</span><br><span class="line">3) &quot;passwords&quot;</span><br><span class="line">4) 1) &quot;ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad&quot;</span><br><span class="line">   2) &quot;6d970874d0db767a7058798973f22cf6589601edab57996312f2ef7b56e5584d&quot;</span><br><span class="line">5) &quot;commands&quot;</span><br><span class="line">6) &quot;-@all&quot;</span><br><span class="line">7) &quot;keys&quot;</span><br><span class="line">8) (empty array)</span><br><span class="line"></span><br><span class="line">## 认证密码</span><br><span class="line">&gt; AUTH zhoujy abc</span><br><span class="line">OK</span><br><span class="line">&gt; AUTH zhoujy cba</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 移除密码</span><br><span class="line">## &lt;开头: &lt;password ，明文密码</span><br><span class="line">&gt; ACL SETUSER zhoujy &lt;abc</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">## 用!开头: !hash，SHA-256哈希值</span><br><span class="line">&gt; ACL SETUSER zhoujy on !6d970874d0db767a7058798973f22cf6589601edab57996312f2ef7b56e5584d</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">## 查看</span><br><span class="line">&gt; ACL GETUSER zhoujy</span><br><span class="line">1) &quot;flags&quot;</span><br><span class="line">2) 1) &quot;on&quot;</span><br><span class="line">3) &quot;passwords&quot;</span><br><span class="line">4) (empty array)</span><br><span class="line">5) &quot;commands&quot;</span><br><span class="line">6) &quot;-@all&quot;</span><br><span class="line">7) &quot;keys&quot;</span><br><span class="line">8) (empty array)</span><br><span class="line"></span><br><span class="line">## 认证密码</span><br><span class="line">&gt; AUTH zhoujy abc</span><br><span class="line">(error) WRONGPASS invalid username-password pair</span><br></pre></td></tr></table></figure><p>2、清理 / 删除密码：通过 nopass 清理用户的密码，但是该用户连接还是需要 AUTH，只是密码可以是任意值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 清理/删除密码，可以用任意密码登陆</span><br><span class="line">## 查看</span><br><span class="line">&gt; ACL GETUSER zhoujy</span><br><span class="line">1) &quot;flags&quot;</span><br><span class="line">2) 1) &quot;on&quot;</span><br><span class="line">   2) &quot;allkeys&quot;</span><br><span class="line">   3) &quot;allcommands&quot;</span><br><span class="line">3) &quot;passwords&quot;</span><br><span class="line">4) 1) &quot;ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad&quot;</span><br><span class="line">   2) &quot;6d970874d0db767a7058798973f22cf6589601edab57996312f2ef7b56e5584d&quot;</span><br><span class="line">5) &quot;commands&quot;</span><br><span class="line">6) &quot;+@all&quot;</span><br><span class="line">7) &quot;keys&quot;</span><br><span class="line">8) 1) &quot;*&quot;</span><br><span class="line"></span><br><span class="line">## 删除、清理用户密码</span><br><span class="line">&gt; ACL SETUSER zhoujy nopass</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">## 查看</span><br><span class="line">&gt; ACL GETUSER zhoujy</span><br><span class="line">1) &quot;flags&quot;</span><br><span class="line">2) 1) &quot;on&quot;</span><br><span class="line">   2) &quot;allkeys&quot;</span><br><span class="line">   3) &quot;allcommands&quot;</span><br><span class="line">   4) &quot;nopass&quot;</span><br><span class="line">3) &quot;passwords&quot;</span><br><span class="line">4) (empty array)</span><br><span class="line">5) &quot;commands&quot;</span><br><span class="line">6) &quot;+@all&quot;</span><br><span class="line">7) &quot;keys&quot;</span><br><span class="line">8) 1) &quot;*&quot;</span><br><span class="line"></span><br><span class="line">## 验证</span><br><span class="line">&gt; AUTH zhoujy  --需要AUTH</span><br><span class="line">(error) WRONGPASS invalid username-password pair</span><br><span class="line"></span><br><span class="line">&gt; AUTH zhoujy &#x27;&#x27;  --可以输入任何密码</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 清理/删除密码，不能登陆，需要设置密码后才能登陆</span><br><span class="line">## 查看</span><br><span class="line">&gt; ACL GETUSER zhoujy</span><br><span class="line">1) &quot;flags&quot;</span><br><span class="line">2) 1) &quot;on&quot;</span><br><span class="line">   2) &quot;allkeys&quot;</span><br><span class="line">   3) &quot;allcommands&quot;</span><br><span class="line">3) &quot;passwords&quot;</span><br><span class="line">4) 1) &quot;ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad&quot;</span><br><span class="line">   2) &quot;6d970874d0db767a7058798973f22cf6589601edab57996312f2ef7b56e5584d&quot;</span><br><span class="line">5) &quot;commands&quot;</span><br><span class="line">6) &quot;+@all&quot;</span><br><span class="line">7) &quot;keys&quot;</span><br><span class="line">8) 1) &quot;*&quot;</span><br><span class="line"></span><br><span class="line">## 删除、清理用户密码</span><br><span class="line">&gt; ACL SETUSER zhoujy resetpass</span><br><span class="line">OK</span><br><span class="line">&gt; ACL GETUSER zhoujy</span><br><span class="line">1) &quot;flags&quot;</span><br><span class="line">2) 1) &quot;on&quot;</span><br><span class="line">   2) &quot;allkeys&quot;</span><br><span class="line">   3) &quot;allcommands&quot;</span><br><span class="line">3) &quot;passwords&quot;</span><br><span class="line">4) (empty array)</span><br><span class="line">5) &quot;commands&quot;</span><br><span class="line">6) &quot;+@all&quot;</span><br><span class="line">7) &quot;keys&quot;</span><br><span class="line">8) 1) &quot;*&quot;</span><br><span class="line"></span><br><span class="line">## 验证，被resetpass重置密码之后，不能登陆，只能设置密码或则设置nopass才能登陆</span><br><span class="line">&gt; AUTH zhoujy</span><br><span class="line">(error) WRONGPASS invalid username-password pair</span><br><span class="line"></span><br><span class="line">&gt; AUTH zhoujy &#x27;&#x27;</span><br><span class="line">(error) WRONGPASS invalid username-password pair</span><br></pre></td></tr></table></figure><p>3、重置用户和密码：实际上是执行 resetpass，resetkeys，off，-@all</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 查看</span><br><span class="line">&gt; ACL LIST</span><br><span class="line">1) &quot;user default on #ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad ~* +@all&quot;</span><br><span class="line">2) &quot;user zhoujy on #ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad ~* +@all&quot;</span><br><span class="line"></span><br><span class="line">## 重置用户</span><br><span class="line">&gt; ACL SETUSER zhoujy reset</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">## 查看</span><br><span class="line">&gt; ACL LIST</span><br><span class="line">1) &quot;user default on #ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad ~* +@all&quot;</span><br><span class="line">2) &quot;user zhoujy off -@all&quot;</span><br></pre></td></tr></table></figure><p>4、获取随机密码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 生成随机密码</span><br><span class="line">&gt; ACL GENPASS</span><br><span class="line">&quot;7a3288b05577cb6fea9b1a9a8bcfe10d9589e64be74e8a0e16c131ba896c7bde&quot;</span><br></pre></td></tr></table></figure><h4 id="键模式"><a href="#键模式" class="headerlink" title="键模式"></a>键模式</h4><p><code>~&lt;pattern&gt;</code>，通配符模式。比如： <del>* 表示允许访问所有 key，也可以用 `<strong>allkeys</strong>来表示**</del>***。**resetkeys** 表示清空它之前所有的键模式，之后的键模式不影响。`</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 可以操作foo开头和bar:开头的所有key</span><br><span class="line">&gt; ACL SETUSER zhoujy on &gt;abc ~foo* ~bar:*+@all</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">## 查看</span><br><span class="line">&gt; ACL LIST</span><br><span class="line">1) &quot;user default on #ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad ~* +@all&quot;</span><br><span class="line">2) &quot;user zhoujy on #ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad ~foo* ~bar:*+@all&quot;</span><br><span class="line"></span><br><span class="line">--  只能操作ob:开头的key，前面的key模式被resetkeys清空了</span><br><span class="line">&gt; ACL SETUSER zhoujy on &gt;abc ~foo* ~bar:* resetkeys ~ob:*+@all</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">## 查看</span><br><span class="line">&gt; ACL LIST</span><br><span class="line">1) &quot;user default on #ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad ~* +@all&quot;</span><br><span class="line">2) &quot;user zhoujy on #ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad ~ob:*+@all&quot;</span><br><span class="line"></span><br><span class="line">-- 操作所有key，allkeys 和 ~* 一样</span><br><span class="line">&gt; ACL SETUSER zhoujy allkeys +@all</span><br><span class="line">OK</span><br><span class="line">&gt; ACL LIST</span><br><span class="line">1) &quot;user default on #ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad ~* +@all&quot;</span><br><span class="line"></span><br><span class="line">## 查看</span><br><span class="line">2) &quot;user zhoujy on #ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad ~*+@all&quot;</span><br></pre></td></tr></table></figure><h4 id="权限相关"><a href="#权限相关" class="headerlink" title="权限相关"></a>权限相关</h4><p>权限这块涉及到的比较多：权限的类别、类别里包含的命令，以及子权限。<br>注意：**-@all** 表示没有任何权限；**+@all** 表示有所有权限；</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 返回权限的类别</span><br><span class="line">&gt; ACL CAT</span><br><span class="line"> 1) &quot;keyspace&quot;</span><br><span class="line"> 2) &quot;read&quot;</span><br><span class="line"> 3) &quot;write&quot;</span><br><span class="line"> 4) &quot;set&quot;</span><br><span class="line"> 5) &quot;sortedset&quot;</span><br><span class="line"> 6) &quot;list&quot;</span><br><span class="line"> 7) &quot;hash&quot;</span><br><span class="line"> 8) &quot;string&quot;</span><br><span class="line"> 9) &quot;bitmap&quot;</span><br><span class="line">10) &quot;hyperloglog&quot;</span><br><span class="line">11) &quot;geo&quot;</span><br><span class="line">12) &quot;stream&quot;</span><br><span class="line">13) &quot;pubsub&quot;</span><br><span class="line">14) &quot;admin&quot;</span><br><span class="line">15) &quot;fast&quot;</span><br><span class="line">16) &quot;slow&quot;</span><br><span class="line">17) &quot;blocking&quot;</span><br><span class="line">18) &quot;dangerous&quot;</span><br><span class="line">19) &quot;connection&quot;</span><br><span class="line">20) &quot;transaction&quot;</span><br><span class="line">21) &quot;scripting&quot;</span><br><span class="line"></span><br><span class="line">-- 返回指定类别中的命令，下面hash是上面返回的一个结果</span><br><span class="line">&gt; ACL CAT hash</span><br><span class="line"> 1) &quot;hsetnx&quot;</span><br><span class="line"> 2) &quot;hset&quot;</span><br><span class="line"> 3) &quot;hlen&quot;</span><br><span class="line"> 4) &quot;hmget&quot;</span><br><span class="line"> 5) &quot;hincrbyfloat&quot;</span><br><span class="line"> 6) &quot;hgetall&quot;</span><br><span class="line"> 7) &quot;hvals&quot;</span><br><span class="line"> 8) &quot;hscan&quot;</span><br><span class="line"> 9) &quot;hkeys&quot;</span><br><span class="line">10) &quot;hstrlen&quot;</span><br><span class="line">11) &quot;hget&quot;</span><br><span class="line">12) &quot;hdel&quot;</span><br><span class="line">13) &quot;hexists&quot;</span><br><span class="line">14) &quot;hincrby&quot;</span><br><span class="line">15) &quot;hmset&quot; </span><br></pre></td></tr></table></figure><p>从上面的权限列表里看到：权限对 key 的类型和命令的类型进行了分类，如有对类型进行分类：string、hash、list、set、sortedset，和对命令类型进行分类：connection、admin、dangerous。 以及对每个分类的方法进行说明，如上面查看 hash 类型 key 的一些方法。</p><p><strong>授权方法</strong>：</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+&lt;command&gt;：将命令添加到用户可以调用的命令列表中，如+@hash</span><br><span class="line">-&lt;command&gt;: 将命令从用户可以调用的命令列表中移除</span><br><span class="line">+@&lt;category&gt;: 添加一类命令，如：@admin, @set, @hash ... 可以ACL CAT 查看具体的操作指令。特殊类别@all表示所有命令，包括当前在服务器中存在的命令，以及将来将通过模块加载的命令</span><br><span class="line">-@&lt;category&gt;: 类似+@&lt;category&gt;，从客户端可以调用的命令列表中删除命令</span><br><span class="line">+&lt;command&gt;|subcommand: 允许否则禁用特定子命令。注意，这种形式不允许像-DEBUG | SEGFAULT那样，而只能以“ +”开头</span><br><span class="line">allcommands：+@all的别名，允许所有命令操作执行。注意，这意味着可以执行将来通过模块系统加载的所有命令。</span><br><span class="line">nocommands：-@all的别名，不允许所有命令操作执行。</span><br></pre></td></tr></table></figure><p>1、添加指定类型的权限：+@hash</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 添加hash类型key的所有权限</span><br><span class="line">&gt; ACL SETUSER zhoujy +@hash</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">## 查看</span><br><span class="line">&gt; ACL LIST</span><br><span class="line">1) &quot;user default on #ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad ~* +@all&quot;</span><br><span class="line">2) &quot;user zhoujy on #ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad ~* -@all +@hash&quot; </span><br></pre></td></tr></table></figure><p><strong>说明</strong>：用户 zhoujy 只有对 hash 类型的 key 有权限。</p><p>2、删除指定类型的权限：-@hash</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 删除hash类型key的所有权限</span><br><span class="line">&gt; ACL SETUSER zhoujy -@hash +@string</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">## 查看</span><br><span class="line">&gt; ACL LIST</span><br><span class="line">1) &quot;user default on #ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad ~* +@all&quot;</span><br><span class="line">2) &quot;user zhoujy on #ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad -@all +@string&quot;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：用户 zhoujy 移除对 hash 类型的 key 有权限。</p><p>3、指定特定 key 的权限：如 sortedset：~z*，z 开头的 key</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 访问指定key的正则</span><br><span class="line">&gt; ACL SETUSER zhoujy ~z* +@sortedset -@string</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">## 查看</span><br><span class="line">&gt; ACL LIST</span><br><span class="line">1) &quot;user default on #ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad ~* +@all&quot;</span><br><span class="line">2) &quot;user zhoujy on #ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad ~z* -@all +@sortedset&quot;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：用户 zhoujy 只有对 z 开头的 key 有权限。</p><p>4、授权只读 / 只写的权限：+@read、+@write</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 授权所有key的只读权限</span><br><span class="line">&gt; ACL SETUSER zhoujy ~* +@read</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">##查看</span><br><span class="line">&gt; ACL LIST</span><br><span class="line">1) &quot;user default on #ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad ~* +@all&quot;</span><br><span class="line">2) &quot;user zhoujy on #ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad ~* -@all +@read +@hash +@bitmap +@geo -georadiusbymember -hsetnx -setbit -hset -geoadd -bitop -hincrbyfloat -hdel -bitfield -hincrby -hmset -georadius&quot;</span><br><span class="line"></span><br><span class="line">-- 授权所有key的只写权限</span><br><span class="line">&gt; ACL SETUSER zhoujy +@write</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">##查看</span><br><span class="line">192.168.163.134:8379&gt; ACL LIST</span><br><span class="line">1) &quot;user default on #ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad ~* +@all&quot;</span><br><span class="line">2) &quot;user zhoujy on #ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad ~* -@all +@write +@list +@string +@stream +@fast +@blocking -dbsize -getrange -scard -xrevrange -zrank -llen -xread -ttl -get -ping -watch -publish -hlen -xrange -stralgo -zcount -getbit -lastsave -readonly -hmget -hello -zcard -discard -hstrlen -xinfo -hget -exists -bitfield_ro -select -role -zlexcount -zrevrank -lolwut -hexists -touch -lindex -unwatch -sismember -strlen -xlen -asking -type -mget -time -xpending -echo -multi -auth -readwrite -lrange -pttl -zscore -substr&quot;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：用户 zhoujy 对所有 key 有只读或则只写的权限，如果下个这对指定 key，则替换 <strong>~*</strong> 即可。</p><p>5、授权管理权限：@admin</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 授权管理权限</span><br><span class="line">&gt; ACL SETUSER zhoujy on &gt;abc ~* +@admin</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">## 查看</span><br><span class="line">&gt; ACL LIST</span><br><span class="line">1) &quot;user default on #ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad ~* +@all&quot;</span><br><span class="line">2) &quot;user zhoujy on #ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad ~* -@all +@admin +@dangerous -flushall -flushdb -swapdb -keys -role -sort -migrate -restore-asking -restore -info&quot;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：用户 zhoujy 有管理权限，包含了危险操作的类型，但排除了 <strong>-</strong> 开头命令的权限。</p><p>6、允许特定类型 key 的子命令权限：</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 设置子命令。</span><br><span class="line">&gt; ACL SETUSER zhoujy on &gt;abc ~* -client +client|getname +client|setname</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">##查看</span><br><span class="line">&gt; ACL LIST</span><br><span class="line">1) &quot;user default on #ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad ~* +@all&quot;</span><br><span class="line">2) &quot;user zhoujy on #ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad ~* -@all +client|getname +client|setname&quot;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：开始删除 CLIENT 命令，然后添加了两个允许的子命令。请注意，不能相反，即不能 + 在前面，只能添加而不是排除子命令，因为将来可能会添加新的子命令。<strong>注意</strong>子命令匹配可能会增加一些性能损失。</p><p>7、特定用途的账号权限：Sentinel 和 Replicas</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- Sentinel：允许用户在主和副本实例中都有以下命令权限</span><br><span class="line">&gt; ACL SETUSER sentinel-user &gt;somepassword +client +subscribe +publish +ping +info +multi +slaveof +config +client +exec on</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">-- Replicas:副本需要在主实例上有以下命令权限</span><br><span class="line">&gt; ACL SETUSER replica-user &gt;somepassword +psync +replconf +ping on</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h4 id="保存、加载相关：save、load"><a href="#保存、加载相关：save、load" class="headerlink" title="保存、加载相关：save、load"></a>保存、加载相关：save、load</h4><p>通过 ACL 创建的用户是保存在内存里的，如果 Redis Server 重启则 ACL 创建的用户会丢失，所以在创建完用户后需要用 <strong>save</strong> 保存，在重启之后需要用 <strong>load</strong> 加载。有两种方式进行保存和加载：</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1，使用ACL命令:ACL SAVE、ACL LOAD</span><br><span class="line">2，使用Redis配置，用户被定义，然后重启服务器并生效。 或者使用外部ACL文件，使用ACL LOAD 来导入ACL信息</span><br></pre></td></tr></table></figure><p><strong>注意：ACL 的配合文件需要事先手动 touch，否则实例启动会失败。</strong>在 redis.conf 里配置和 acl 文件里配置的方法互不兼容，Redis 会要求使用其中一种。 否则实例启动报错：</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 报错信息</span><br><span class="line">#Configuring Redis with users defined in redis.conf and at the same setting an ACL file path is invalid. This setup is very likely to lead to configuration errors and security holes, please define either an ACL file or declare users directly in your redis.conf, but not both.</span><br></pre></td></tr></table></figure><p>在 redis.conf 中指定用户是一种非常简单的方法，适用于简单的用例。 当有多个用户要定义时，在复杂的环境中，强烈建议使用 ACL 文件。该 2 个文件里的配置内容是一致的，可以相互进行配置，如格式如下：在 redis.conf 和 users.acl 里的格式</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 配置文件</span><br><span class="line">user default on #ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad ~* +@all</span><br><span class="line">user zhoujy on #ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad ~* +@all</span><br></pre></td></tr></table></figure><p>1、保存 ACL 规则</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 保存ACL规则</span><br><span class="line">&gt; ACL SAVE</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>2、加载 ACL 规则</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 加载ACL规则</span><br><span class="line">&gt; ACL LOAD</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：在使用 ACL 配置文件之后，如果设置了默认用户（default）规则的话，需要看配置文件中 aclfile 和 requirepass 参数的先后顺序，密码以最后出现的为准。</p><h4 id="日志相关"><a href="#日志相关" class="headerlink" title="日志相关"></a>日志相关</h4><p>显示最近的 ACL 安全事件列表<br>通过 ACL LOG [<count> | RESET] 返回 ACL 的日志信息，可以指定条目显示，也可以进行重置：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 显示日志信息</span><br><span class="line">&gt; ACL LOG 1</span><br><span class="line">1)  1) &quot;count&quot;</span><br><span class="line">    2) (integer) 1</span><br><span class="line">    3) &quot;reason&quot;</span><br><span class="line">    4) &quot;auth&quot;</span><br><span class="line">    5) &quot;context&quot;</span><br><span class="line">    6) &quot;toplevel&quot;</span><br><span class="line">    7) &quot;object&quot;</span><br><span class="line">    8) &quot;AUTH&quot;</span><br><span class="line">    9) &quot;username&quot;</span><br><span class="line">   10) &quot;zhoujy&quot;</span><br><span class="line">   11) &quot;age-seconds&quot;</span><br><span class="line">   12) &quot;282.90499999999997&quot;</span><br><span class="line">   13) &quot;client-info&quot;</span><br><span class="line">   14) &quot;id=5 addr=192.168.163.134:35246 fd=7 name= age=403 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=36 qbuf-free=32732 obl=0 oll=0 omem=0 events=r cmd=auth user=zhoujy&quot;</span><br><span class="line"></span><br><span class="line">-- 重置日志，类似slow</span><br><span class="line">&gt; acl log reset</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h2 id="场景说明"><a href="#场景说明" class="headerlink" title="场景说明"></a>场景说明</h2><p><strong>注意：</strong>以上操作完只有需要执行 ACL SAVE。不然重置之后用户信息全部都清空了。</p><ol><li><p>创建 DBA 管理账号</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; ACL SETUSER dba on #6d0ac515af9df81653ed0aa3ffa692663c3f556079791e2f00a4578990da66f3 allkeys +@all</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li><li><p>创建读写账号</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; ACL SETUSER readwrite on &gt;abc allkeys -@all +@read +@write</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li><li><p>创建只读账号</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; ACL SETUSER readonly on &gt;abc allkeys -@all +@read</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li><li><p>创建只写账号</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; ACL SETUSER write_user on &gt;abc allkeys -@all +@write</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li><li><p>创建复制账号</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; ACL SETUSER replica-user &gt;abc -@all +psync +replconf +ping on</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li><li><p>创建哨兵账号</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; ACL SETUSER sentinel-user &gt;abc -@all +client +subscribe +publish +ping +info +multi +slaveof +config +client +exec on</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li><li><p>创建监控账号</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; ACL SETUSER monitor on &gt;abc +monitor</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li><li><p>创建指定 key、有指定类型权限的账号</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 指定对h开头的hash类型的key有权限</span><br><span class="line">&gt; ACL SETUSER ops_user on &gt;abc ~h* +@hash</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>其中 key 的模式是正则匹配，需要 <strong>~</strong> 开头，针对权限则是 hash 的类，其权限可以通过 ACL CAT hash 查看。</p></li></ol><h2 id="使用外部-ACL-文件"><a href="#使用外部-ACL-文件" class="headerlink" title="使用外部 ACL 文件"></a>使用外部 ACL 文件</h2><p>有两种方法可以将用户存储在 Redis 配置中，一种是 <code>redis.conf</code> 中配置，一种是使用一个独立的外部 acl 文件，这两种方式不兼容，只能选择一种方式。</p><p>在<code>redis.conf</code>内部指定用户是一种非常简单的方法，适用于简单的用例。当需要定义多个用户时，在复杂的环境中，我们强烈建议您使用 ACL 文件。</p><p>通常外部文件的方式更灵活，推荐使用。</p><p>配置内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user &lt;username&gt; ... acl rules ...</span><br></pre></td></tr></table></figure><p>来看一个示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user worker +@list +@connection ~jobs:* on &gt;ffa9203c493aa99</span><br></pre></td></tr></table></figure><p>当您要使用外部 ACL 文件时，需要在 redis.conf 文件中设置 <code>aclfile</code>文件的路径，如下所示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aclfile /etc/redis/users.acl</span><br></pre></td></tr></table></figure><p>当仅在 redis.conf 文件内部直接指定几个用户时，可以使用 CONFIG REWRITE 以便通过重写将新的用户配置存储在文件中。</p><p>但是，外部 ACL 文件功能更强大。您可以执行以下操作：</p><ul><li>使用 <code>ACL LOAD</code> 重新加载外部 ACL 文件，通常在你手动修改了这个文件，希望 redis 重新加载的时候使用，需要注意的是要确保 acl 文件内容的正确性</li><li>使用 <code>ACL SAVE</code> 将当前 ACL 配置保存到一个外部文件</li></ul><div class="note success flat"><p><strong>参考文档</strong></p><p><a href="https://redis.io/topics/acl">https://redis.io/topics/acl</a></p><p><a href="https://redis.io/commands/acl-setuser">https://redis.io/commands/acl-setuser</a></p></div>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Github Action实现Github到Gitee的持续同步</title>
      <link href="/2021/08/17/2021-08-17-github-to-gitee/"/>
      <url>/2021/08/17/2021-08-17-github-to-gitee/</url>
      
        <content type="html"><![CDATA[<div class="note success flat"><p>文章转载</p><p>作者：SSgeek</p><p>链接：<a href="https://mp.weixin.qq.com/s/9IvYUurEqw9JU1UR714Yow">https://mp.weixin.qq.com/s/9IvYUurEqw9JU1UR714Yow</a></p><p>来源：仙人技术</p></div><h3 id="1、什么是Github-Action"><a href="#1、什么是Github-Action" class="headerlink" title="1、什么是Github Action"></a>1、什么是Github Action</h3><p><code>github action</code>是<code>github</code>推出的自动化<code>CI/CD</code>的功能，随着<code>2019</code>年<code>11</code>月后<code>github</code>对该功能的全面开放，现在所有的<code>github</code>用户可以直接使用该功能</p><p><code>github action</code>的语法类似于<code>gitlab ci</code>，与之相比，还有更多优势，例如：</p><ul><li><code>action</code>对<code>github</code>各个事件的支持更为全面，如<code>release</code>、<code>pull-request</code>、<code>issue</code>事件等等</li><li><code>action</code>支持直接使用别人编写好的<code>action</code></li><li><code>action</code>的执行器类似于<code>gitlab runner</code>，可以使用<code>github</code>托管的执行器，也可以托管自己的执行器。甚至在<code>action</code>运行的时候，还可以通过某些特殊技巧进入到执行器里面，相当于一台临时的服务器供我们使用</li></ul><p>更多这里不再介绍，感兴趣的小伙伴可以自行搜索</p><h3 id="2、github-和-gitee-同步"><a href="#2、github-和-gitee-同步" class="headerlink" title="2、github 和 gitee 同步"></a>2、github 和 gitee 同步</h3><p><code>github</code>的服务器在国外，因为某些原因，在大多数的网络环境下都是无法顺畅访问的</p><p><code>gitee</code>的服务器在国内，由国内公司运营</p><p>纵使如此，大多数开发者还是习惯使用<code>github</code>（远在海外，也要想尽各种办法）</p><p>那么为什么需要把<code>github</code>和<code>gitee</code>的仓库进行同步呢？原因不言而喻</p><p>目前可用的进行同步的方法可能有：</p><ul><li><p>利用<code>gitee</code>官方的同步（导入<code>github</code>项目），这种方法只能一次性导入</p></li><li><p>本地同时关联<code>gitee</code>和<code>github</code>，提交时都<code>push</code>一份，这种方法纯属手动</p></li><li><p>利用<code>github action</code></p></li></ul><p>下面介绍利用<code>github action</code>如何实现<code>github</code>到<code>gitee</code>的持续同步</p><h2 id="3、选用或编写-action"><a href="#3、选用或编写-action" class="headerlink" title="3、选用或编写 action"></a>3、选用或编写 action</h2><p>实现<code>github</code>和<code>gitee</code>同步的思路主要是基于我们的账户调用<code>github</code>和<code>gitee</code>各自的<code>api</code>接口和密钥通信，在执行器内拉取并推送代码库到<code>gitee</code></p><p><code>action</code>的编写语法和<code>gitlab ci</code>很相似，同时<code>github</code>还推出了官方的<code>action</code>市场，地址为 <a href="https://github.com/marketplace">https://github.com/marketplace</a></p><p>这里我们使用的<code>action</code>是<a href="https://github.com/marketplace/actions/hub-mirror-action">Yikun/hub-mirror-action</a></p><h2 id="4、准备5-1-设置-dst-key"><a href="#4、准备5-1-设置-dst-key" class="headerlink" title="4、准备5.1 设置 dst_key"></a>4、准备5.1 设置 dst_key</h2><p>在<code>github</code>上打开一个自己的仓库，这里以我的个人公开仓库为例</p><p>首先在本地生成一个<code>ssh</code>密钥对工作</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ssh-keygen -t rsa -f ~/Documents/ssh-key/id_rsa</span></span><br></pre></td></tr></table></figure><p>在<code>github</code>打开<code>settings</code>—&gt;<code>secrets</code>，新建一个<code>secret</code>，名为<code>GITEE_PRIVATE_KEY</code>，值为上面生成的密钥对的私钥</p><p>然后登录到<code>gitee</code>，在个人设置—&gt;安全设置—&gt;<code>SSH</code>公钥中添加上面生成的密钥对的公钥，命名随意</p><h3 id="5-2-设置-dst-token"><a href="#5-2-设置-dst-token" class="headerlink" title="5.2 设置 dst_token"></a>5.2 设置 dst_token</h3><p>在<code>gitee</code>打开个人设置—&gt;安全设置—&gt;私人令牌，新建一个私人令牌，命名随意，复制生成的令牌值</p><p>在<code>github</code>打开<code>settings</code>—&gt;<code>secrets</code>，新建一个<code>secret</code>，名为<code>GITEE_TOKEN</code>，值为上面复制的令牌值</p><h2 id="6、github-同步到-gitee"><a href="#6、github-同步到-gitee" class="headerlink" title="6、github 同步到 gitee"></a>6、github 同步到 gitee</h2><p>在刚才的<code>GitHub</code>仓库中，新建 <code>.github/workflows/SyncToGitee.yml</code> 文件，<strong>其中<code>.github/workflows/</code>是固定的目录名</strong></p><p>内容如下</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Sync</span> <span class="string">Github</span> <span class="string">Repos</span> <span class="string">To</span> <span class="string">Gitee</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-20.04</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Sync</span> <span class="string">Github</span> <span class="string">Repos</span> <span class="string">To</span> <span class="string">Gitee</span>  <span class="comment"># 名字随便起</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">Yikun/hub-mirror-action@v1.1</span>  <span class="comment"># 使用Yikun/hub-mirror-action</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">src:</span> <span class="string">github/like-ycy</span>  <span class="comment"># 源端账户名(github)</span></span><br><span class="line">        <span class="attr">dst:</span> <span class="string">gitee/like-ycy</span>  <span class="comment"># 目的端账户名(gitee)</span></span><br><span class="line">        <span class="attr">dst_key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITEE_PRIVATE_KEY</span> <span class="string">&#125;&#125;</span>  <span class="comment"># SSH密钥对中的私钥</span></span><br><span class="line">        <span class="attr">dst_token:</span>  <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITEE_TOKEN</span> <span class="string">&#125;&#125;</span>  <span class="comment"># Gitee账户的私人令牌</span></span><br><span class="line">        <span class="attr">account_type:</span> <span class="string">user</span>  <span class="comment"># 账户类型</span></span><br><span class="line">        <span class="attr">clone_style:</span> <span class="string">&quot;https&quot;</span>  <span class="comment"># 使用https方式进行clone，也可以使用ssh</span></span><br><span class="line">        <span class="attr">debug:</span> <span class="literal">true</span>  <span class="comment"># 启用后会显示所有执行命令</span></span><br><span class="line">        <span class="attr">force_update:</span> <span class="literal">true</span>  <span class="comment"># 启用后，强制同步，即强制覆盖目的端仓库</span></span><br><span class="line">        <span class="attr">static_list:</span> <span class="string">&quot;Linux-Commands&quot;</span>  <span class="comment"># 静态同步列表，在此填写需要同步的仓库名称，可填写多个</span></span><br><span class="line">        <span class="attr">timeout:</span> <span class="string">&#x27;600s&#x27;</span>  <span class="comment"># git超时设置，超时后会自动重试git操作</span></span><br></pre></td></tr></table></figure><p>提交该<code>action</code>，观察<code>github</code>上的执行视图</p><p>执行完毕后</p><p>此时打开<code>gitee</code>，就会发现自动创建了同名称的仓库且自动提交了同样的代码</p>]]></content>
      
      
      <categories>
          
          <category> Github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> Gitee </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dockerfile就这么简单</title>
      <link href="/2020/07/20/2020-07-20-dockerfile/"/>
      <url>/2020/07/20/2020-07-20-dockerfile/</url>
      
        <content type="html"><![CDATA[<p>当我们在使用docker时，最重要的就是镜像，只要有了镜像，我们就可以随时随地的根据镜像来创建一个容器，从而做到让我们的服务可以在任何时间任何地点任何环境下运行起来。那么镜像是怎么制作的呢？总体来讲，制作镜像有两种方法：</p><ol><li>根据一个已有的镜像运行容器，然后根据这个容器来制作我们自己的镜像；</li><li>使用DockerFile来制作一个镜像模板文件，使用这个文件来创建镜像；</li></ol><p>对于第一种方法，我们在上一篇文章中最后有提及，就是利用docker commit命令，将我们的变更打包成一个新的镜像。但是这种方法需要我们每次都运行一个容器，然后在容器中做更改后再打包，很明显这种方式效率很低，而且更改不方便。所以这种方式一般不建议大家采用。我们更多的要使用DockerFile的方式来定制我们的镜像，接下来，我们就详细的介绍一下DockerFile的制作方法。</p><h1 id="一、利用Dockerfile制作镜像的准备工作"><a href="#一、利用Dockerfile制作镜像的准备工作" class="headerlink" title="一、利用Dockerfile制作镜像的准备工作"></a>一、利用Dockerfile制作镜像的准备工作</h1><p>在制作Dockerfile前，我们需要做一系列的准备工作。首先，我们要创建一个目录，用来存储我们的Dockerfile，我们需要打包进镜像中的所有文件也都要放在这个这个目录下，我们制作镜像的时候也要在这个目录下来完成。其次，我们要创建一个文件名为Dockerfile，这个文件必须是大写开头，文件名必须为Dockerfile。当我们编写好我们的Dockerfile文件后，我们需要用docker build命令来执行创建镜像。</p><h1 id="二、Dockerfile指令"><a href="#二、Dockerfile指令" class="headerlink" title="二、Dockerfile指令"></a>二、Dockerfile指令</h1><p>我们准备好相关的目录和文件后，我们就可以开始编写我们的Dockerfile了，Dockerfile其实就是由一些指令组合成的，在Dockerfile中一行就是一条指令，每行开头的第一个单词就是指令本身，指令可以用大写也可以用小写，但是一般我们使用大写来表示指令。</p><h2 id="1-FROM指令"><a href="#1-FROM指令" class="headerlink" title="1. FROM指令"></a>1. FROM指令</h2><p>每一个Dockerfile的第一个非注释行都必须使用FROM指令，这个指令指明了我们制作镜像使用的基础镜像，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM &lt;镜像仓库名&gt;[:tag]</span><br><span class="line">FROM &lt;镜像仓库名&gt;@&lt;镜像哈希值&gt;</span><br></pre></td></tr></table></figure><p>默认情况下，docker build命令会优先从本地查找我们使用到的基础镜像，如果找不到则自动去我们的镜像仓库中查找。我们在指定基础镜像的过程中可以使用镜像名，但是此时会出现一个问题，如果有人恶意更改了镜像名，用一个错误的镜像替换了我们正常的镜像，那么此时我们就会拉取到错误的镜像。为了避免这个问题的出现，我们可以使用镜像的哈希值来指定基础镜像，就是我们上面提到的使用@符号，这样一来我们使用的镜像就不会被恶意替换掉了。</p><p>FROM指令在使用镜像名时，可以省略标签名，默认会使用latest标签。</p><p>我们上面说了，每一个Dockerfile的第一个非注释行都必须使用FROM开头，但是ARG指令是唯一一个可以在FROM指令前出现的指令，这是一个例外的情况。</p><h2 id="2-LABEL指令"><a href="#2-LABEL指令" class="headerlink" title="2. LABEL指令"></a>2. LABEL指令</h2><p>LABEL指令用来指定一些元数据的，比如指定这个镜像文件的作者，联系方式，描述信息等等，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LABEL key1=value1 key2=value2 ... keyN=valueN</span><br></pre></td></tr></table></figure><p>在docker的早期版本中并没有LABEL指令，而是使用MAINTAINER指令，MAINTAINER指令后面只能跟一个字符串，用来指定作者的信息，在新版的docker中，这个指令已经被弃用，官方推荐使用LABEL指令来实现。</p><h2 id="3-RUN指令"><a href="#3-RUN指令" class="headerlink" title="3. RUN指令"></a>3. RUN指令</h2><p>RUN指令用来在创建镜像过程中执行一些命令，RUN指令有两种格式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RUN &lt;command&gt;      直接跟命令</span><br><span class="line">RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]    命令和其参数作为一个列表传入</span><br></pre></td></tr></table></figure><p>这两种方式有不同的效果，RUN指令后直接跟一个命令，会将此命令运行在一个shell中，在linux中默认是/bin/sh，这也就意味着我们可以在命令字符串中引用一些shell变量。但是在第二种方式中，所有的命令和参数放在了一个列表中传入，此时就无法引用shell中的变量。</p><p>除此之外，还有一点需要注意，就是在列表中一定不要用单引号来包裹参数，每个元素都要用双引号，否则会出现docker镜像运行错误的问题。原因就是docker build时会把这些列表当做json来处理，所以要符合json字符串的规则。</p><p>RUN指令执行的命令的结果会被打包到镜像当中，而且Dockerfile中后续的指令也可以使用。使用SHELL指令可以改变默认使用的shell。</p><h2 id="4-CMD指令"><a href="#4-CMD指令" class="headerlink" title="4. CMD指令"></a>4. CMD指令</h2><p>CMD指令是用来指定基于我们的镜像创建容器时，容器中运行的命令的，和RUN不同的地方在于，RUN是在构建镜像时执行的命令，CDM是在创建容器时执行的命令。在一个Dockerfile中只可以有一个CDM指令，如果定义了多个CMD指令，那只有最后一个CMD指令会生效。CMD指令使用格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec form, this is the preferred form exec格式，这是推荐的格式)</span><br><span class="line">CMD [&quot;param1&quot;,&quot;param2&quot;] (as default parameters to ENTRYPOINT 为ENTRYPOINT参数提供参数)</span><br><span class="line">CMD command param1 param2 (shell form shell格式的命令)</span><br></pre></td></tr></table></figure><p>CMD指令可以直接指定一个可执行命令，就是上述的第一和第三种方式，当创建容器时会去执行这个命令，而且需要注意的是，第三种方式是默认在shell中执行的，可以引用shell变量，而第一种方式并不会启动shell，所以就无法引用shell变量。</p><p>在采用第二种方式时，此时并没有指定可执行的命令，而是只指定了参数，此时，这些参数将作为ENTRYPOINT指令的参数，关于ENTRYPOINT指令，我们稍后介绍。</p><h2 id="5-ENTRYPOINT指令"><a href="#5-ENTRYPOINT指令" class="headerlink" title="5. ENTRYPOINT指令"></a>5. ENTRYPOINT指令</h2><p>ENTRYPOINT指令也是用来指定基于我们的镜像创建容器时需要执行的命令的，其使用格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (exec form, preferred 推荐格式，使用json)</span><br><span class="line">ENTRYPOINT command param1 param2 (shell form shell格式)</span><br></pre></td></tr></table></figure><p>既然我们已经有了CMD指令了，那为什么我们还要弄一个ENTRYPOINT指令出来呢？这两者的区别在于，当我们使用CMD指令创建好镜像后，在使用这个镜像启动容器时，我们可以改变容器默认的命令，而自己定义启动容器时的命令，比如我们的CMD指令是启动nginx，但是我们在启动容器的时候可以指定命令来启动一个bash，此时，我们在命令行中指定的指令就替换掉了我们的CMD命令。但是我们如果使用ENTRYPOINT指令来指定执行的命令，那么在命令行中启动镜像时，在镜像名之后我们自己指定的命令将不会执行，而是作为参数传递给了ENTRYPOINT命令。而且，在命令行中指定的命令，第一个参数并没有被传递给<code>ENTRYPOINT</code>，这是因为我们的docker默认认为第一个参数是要执行的命令，而其之后的才是真正的参数，参见如下所示，我们的“echo” 字符串并没有被输出出来：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost img1]# cat Dockerfile</span><br><span class="line">FROM centos:centos7</span><br><span class="line">ENTRYPOINT echo &quot;abc&quot; $@</span><br><span class="line">[root@localhost img1]# docker run --rm centos:testv3 echo aaaaa bbbbb ccccc</span><br><span class="line">abc aaaaa bbbbb ccccc</span><br><span class="line">[root@localhost img1]#</span><br></pre></td></tr></table></figure><p>这个特性可以使我们在运行容器时禁止自定义启动命令，保证了容器运行结果与我们的预期完全一致。但是，我们并不是完全不能更改这个命令，docker为我们提供了<code>--entrypoint</code>参数来修改这个命令。但是这个参数和命令要写在镜像名之前才会生效。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost img1]# cat Dockerfile</span><br><span class="line">FROM centos:centos7</span><br><span class="line">ENTRYPOINT echo &quot;abc&quot;</span><br><span class="line">[root@localhost img1]# docker run -ti --rm centos:testv1 --entrypoint /bin/bash</span><br><span class="line">abc</span><br><span class="line">[root@localhost img1]# docker run -ti --rm --entrypoint /bin/bash centos:testv1</span><br><span class="line">[root@a0c502e6ba2f /]# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>在上面CMD命令的部分，我们可以给<code>CMD</code>命令不指定执行的命令而只指定参数，此时这些参数就会被传递给ENTRYPOINT指令。</p><p>此外，还需要注意一点，我们使用列表的格式来编写命令时，要注意使用双引号来包裹各个参数，而不是单引号。</p><p>Shell形式可防止使用任何CMD或<code>run</code> 命令行参数覆盖掉我们的运行命令，但具有以下缺点：ENTRYPOINT将作为<code>/bin/sh -c</code>的子命令启动，该子命令不传递信号。这意味着可执行文件将不是容器的<code>PID 1</code>，并且不会接收Unix信号，因此您的可执行文件将不会从<code>docker stop &lt;container&gt;</code>接收到<code>SIGTERM</code>。</p><h2 id="6-EXPOSE指令"><a href="#6-EXPOSE指令" class="headerlink" title="6. EXPOSE指令"></a>6. EXPOSE指令</h2><p>EXPOSE指令是用来暴露容器的端口的，其使用格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</span><br></pre></td></tr></table></figure><p>这个指令可以一次性指定暴露多个端口，且可以指定端口的协议，默认情况下是使用TCP协议，我们还可以自己定义使用的协议：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPOSE 8080/udp  暴露UDP协议的8080端口</span><br></pre></td></tr></table></figure><p>但是需要注意的是，在使用了EXPOSE指令后指定的端口，在运行容器时并不会自动的建立容器和宿主机的映射关系，而是当我们运行容器时指定-P选项后其才会将这些端口映射到宿主机上，且我们在定义Dockerfile时不能指定容器端口映射到宿主机上的端口，只能是随机映射一个宿主机上的端口。</p><h2 id="7-ENV指令"><a href="#7-ENV指令" class="headerlink" title="7. ENV指令"></a>7. ENV指令</h2><p>ENV指令用于创建环境变量，这些环境变量可以在构建镜像阶段供Dockerfile之后的指令所引用，其格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">ENV &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure><p>第一种格式用来设置单个的环境变量，ENV指令后被空格分隔的第一个字符串会被当成是环境变量的KEY，后面的所有值都会被当成是该KEY的VALUE值，第二种格式可以一次设置多个环境变量，使用等号来声明KEY和VALUE，如果VALUE部分包含空格，我们可以用引号将VALUE部分引起来，也可以用反斜杠对空格做转义处理。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 第一种格式，一行定义一对环境变量</span><br><span class="line">ENV myName John Doe</span><br><span class="line">ENV myDog Rex The Dog</span><br><span class="line">ENV myCat fluffy</span><br><span class="line"></span><br><span class="line"># 第二种方式，一行定义多对环境变量</span><br><span class="line">ENV myName=&quot;John Doe&quot; myDog=Rex\ The\ Dog \</span><br><span class="line">    myCat=fluffy</span><br></pre></td></tr></table></figure><p>通过ENV指令设置的环境变量将被保留在生成的镜像中，我们用此镜像创建容器后，可以用docker inspect 命令来查看，也可以在运行容器时，使用<code>docker run --env &lt;key&gt;=&lt;value&gt;</code>的方式来指定。</p><h2 id="8-ADD指令"><a href="#8-ADD指令" class="headerlink" title="8. ADD指令"></a>8. ADD指令</h2><p>ADD指令用来向镜像中添加文件，其有两种格式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">ADD [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span><br></pre></td></tr></table></figure><p><code>--chown</code>选项可以在添加文件时改变文件的属主和属组，但是需要注意，这个特性只支持Linux类型的容器，在windows容器上不起作用。</p><p>ADD指令可以从<code>&lt;src&gt;</code>指定的文件、目录或者URL拷贝文件到镜像文件系统中的<code>&lt;dest&gt;</code>路径下，并且可以指定多个<code>&lt;src&gt;</code>，在有多个<code>&lt;src&gt;</code>时，最后一个作为目的地址，其前面的字段都会作为<code>&lt;src&gt;</code>字段。同时，在原地址字段中，也支持正则匹配。并且，目的地址是一个绝对路径，或者当<code>WORKDIR</code>指令指定了工作目录后，也可以是这个目录下的相对路径。而原文件必须在Dockerfile所在的目录下或其子目录下。</p><p>添加包含特殊字符（例如[和]）的文件或目录时，您需要按照Golang规则转义那些路径，以防止将它们视为匹配模式。例如，要添加名为arr [0] .txt的文件，请使用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD arr[[]0].txt /mydir/    # copy a file named &quot;arr[0].txt&quot; to /mydir/</span><br></pre></td></tr></table></figure><p>如果没有添加<code>--chown</code>标志，所有新添加的文件或目录属主属组默认是0。<code>--chown</code>标志允许提供属主名和属组名，如果提供了用户名或组名，则将使用容器的根文件系统<code>/etc/passwd</code>和<code>/etc/group</code>文件分别执行从名称到整数UID或GID的转换，也可以提供其对应的UID和GID，如果只提供了属主，则默认会使用和属主UID相同的GID来指定属组，如下都是正确的定义格式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD --chown=55:mygroup files* /somedir/</span><br><span class="line">ADD --chown=bin files* /somedir/</span><br><span class="line">ADD --chown=1 files* /somedir/</span><br><span class="line">ADD --chown=10:11 files* /somedir/</span><br></pre></td></tr></table></figure><p>如果通过<code>--chown</code>标志使用用户名或者属主名来指定属主或属组，而在容器的文件系统中不存在 <code>/etc/passwd</code> 或者 <code>/etc/group</code> 文件，此时构建镜像时会在ADD操作时失败。但是使用数字来指定时，创建镜像的时候并不会去查找此UID或GID是否存在，也不会依赖容器的根文件系统。需要注意的是，如果源文件是一个URL，而这个URL需要登录认证的话，那么需要使用wget或者curl的方式来下载文件，ADD指令并不能完成登录认证。</p><p><strong>「ADD指令遵循如下的规则：」</strong></p><ol><li>如果是URL，并且不以斜杠结尾，则从URL下载文件并将其复制到;</li><li>如果是URL，并且以斜杠结尾，则从URL推断文件名，并将文件下载到/。例如，ADD <a href="http://example.com/foobar">http://example.com/foobar</a> /，将创建文件 /foobar。该URL必须具有具体的路径及文件名，以便在这种情况下可以找到适当的文件名（例如这样的URL：<a href="http://example.com将不起作用)/">http://example.com将不起作用）</a>;</li><li>如果是目录，则将复制目录的整个内容，包括文件系统元数据。注意，此时目录本身并不会被复制，而是递归复制这个目录下的所有文件;</li><li>当是本地的一个通过gzip, bzip2 or xz压缩的tar压缩包，ADD指令会自动将这个包解压。但是如果是一个URL时则不会解压。</li></ol><blockquote><p>❝</p><p><strong>「注意」</strong>：文件是否被识别为压缩格式仅根据文件的内容而不是文件的名称来确定。例如，如果一个空文件碰巧以.tar.gz结尾，则该文件将不会被识别为压缩文件，并且不会生成任何类型的解压缩错误消息，而是会将文件简单地复制到目标位置。</p><p>❞</p></blockquote><ol><li>如果是任何其他类型的文件，则将其与其元数据一起单独复制。在这种情况下，如果以尾斜杠/结束，则它将被视为目录，并且的内容将写入/base();</li><li>如果直接或由于使用通配符而指定了多个资源，则必须是目录，并且必须以斜杠/结尾;</li><li>如果不以斜杠结尾，它将被视为常规文件，并且的内容将写入;</li><li>如果不存在，它将与路径中所有缺少的目录一起创建。</li></ol><h2 id="9-COPY指令"><a href="#9-COPY指令" class="headerlink" title="9. COPY指令"></a>9. COPY指令</h2><p>COPY用于向镜像中复制文件，用法与ADD指令类似，但是也有一些区别，其格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span><br></pre></td></tr></table></figure><p>COPY指令也可以复制多个文件，也支持通配符匹配，用法基本类似ADD指令，但是COPY指令只能接受一个本地文件或目录，不能COPY远程的URL。而且COPY的文件也必须放在Dockerfile同级目录或其同级目录之下的目录中。</p><p><strong>「COPY指令遵循如下规则：」</strong></p><ol><li>如果是目录，则将复制目录的整个内容，包括文件系统元数据。且目录本身不被复制，仅其内容被复制；</li><li>如果是任何其他类型的文件，则将其与其元数据一起单独复制。在这种情况下，如果以尾斜杠/结束，则它将被视为目录，并且的内容将写入/base()；</li><li>如果直接或由于使用通配符而指定了多个资源，则必须是目录，并且必须以斜杠/结尾；</li><li>如果不以斜杠结尾，它将被视为常规文件，并且的内容将写入；</li><li>如果不存在，它将与路径中所有缺少的目录一起创建；</li></ol><h2 id="10-VOLUME指令"><a href="#10-VOLUME指令" class="headerlink" title="10. VOLUME指令"></a>10. VOLUME指令</h2><p>VOLUME指令用于挂载宿主机上的目录到容器中，其格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VOLUME [&quot;/data&quot;]</span><br></pre></td></tr></table></figure><p>VOLUME指令创建具有指定名称的挂载点，并将其标记为保存来自本地主机或其他容器的外部安装的卷。该值可以是JSON数组，<code>VOLUME [&quot;/var/log/&quot;]</code> 或具有多个参数的纯字符串，例如<code>VOLUME /var/log</code> 或 <code>VOLUME /var/log/var/db</code>。在指定挂载点后，docker创建容器时，会把挂载点下已经存在的文件移动到卷中。</p><p>关于Dockerfile中的卷，请记住以下几点。</p><ol><li><p>基于Windows的容器上的卷：使用基于Windows的容器时，容器内的卷的目的地必须是以下之一：</p><p>a、不存在的或空目录</p><p>b、C盘以外的磁盘分区</p></li><li><p>从Dockerfile内更改卷：如果在声明了卷后有任何构建步骤更改了卷内的数据，则这些更改将被丢弃;</p></li><li><p>JSON格式：列表被解析为JSON数组。您必须用双引号（”）而不是单引号（’）括起单词;</p></li><li><p>主机目录在容器运行时声明：主机目录（挂载点）从本质上说是依赖于主机的。这是为了保留镜像的可移植性，因为不能保证给定的主机目录在所有主机上都可用。因此，您无法从Dockerfile中挂载主机目录。VOLUME指令不支持指定host-dir参数。创建或运行容器时，必须指定挂载点。</p></li></ol><h2 id="11-USER指令"><a href="#11-USER指令" class="headerlink" title="11. USER指令"></a>11. USER指令</h2><p>USER指令设置运行镜像时要使用的用户名（或UID）以及可选的用户组（或GID），以及Dockerfile中的所有RUN，CMD和ENTRYPOINT指令。其格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USER &lt;user&gt;[:&lt;group&gt;] or</span><br><span class="line">USER &lt;UID&gt;[:&lt;GID&gt;]</span><br></pre></td></tr></table></figure><h2 id="12、WORKDIR指令"><a href="#12、WORKDIR指令" class="headerlink" title="12、WORKDIR指令"></a>12、WORKDIR指令</h2><p>WORKDIR指令为Dockerfile中跟在其后的所有RUN，CMD，ENTRYPOINT，COPY和ADD指令设置工作目录。如果WORKDIR不存在，即使以后的Dockerfile指令中未使用，它也将被创建。其格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WORKDIR /path/to/workdir</span><br></pre></td></tr></table></figure><p>WORKDIR指令可在Dockerfile中多次使用。如果提供了相对路径，则它将相对于上一个WORKDIR指令的路径。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WORKDIR /a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure><p>该Dockerfile中最后一个pwd命令的输出为<code>/a/b/c</code>。</p><p>WORKDIR指令可以解析以前使用ENV设置的环境变量。你只能使用在Dockerfile中显式设置的环境变量。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENV DIRPATH /path</span><br><span class="line">WORKDIR $DIRPATH/$DIRNAME</span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure><p>pwd命令的运行结果就是<code>/path/$DIRNAME</code>。</p><h2 id="13-ARG指令"><a href="#13-ARG指令" class="headerlink" title="13. ARG指令"></a>13. ARG指令</h2><p>ARG指令定义了一个变量，用户可以在创建镜像时使用–build-arg=参数将其传递给构建器。如果用户指定了未在Dockerfile中定义的ARG变量，则构建会输出警告。其格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ARG &lt;name&gt;[=&lt;default value&gt;]</span><br></pre></td></tr></table></figure><p>在Dockerfile中可以包含一个或多个变量。</p><blockquote><p>❝</p><p><strong>「注意:」</strong> 不建议使用创建镜像时使用变量来传递诸如github密钥，用户凭据等机密。创建镜像时变量值对于使用docker history命令的镜像的任何用户都是可见的。</p><p>❞</p></blockquote><p>在定义ARG变量时，可以给变量赋初值，如果在创建镜像时没有传入变量值，那么就会使用这个初始值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM busybox</span><br><span class="line">ARG user1=someuser</span><br><span class="line">ARG buildno=1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>ARG变量也遵从先定义后使用的惯例，而且，Dockerfile中后定义的同名变量会覆盖之前的变量的值。</p><p>可以使用ARG或ENV指令来指定RUN指令可用的变量。使用ENV指令定义的环境变量始终会覆盖同名的ARG指令。我们来看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ARG CONT_IMG_VER</span><br><span class="line">ENV CONT_IMG_VER v1.0.0</span><br><span class="line">RUN echo $CONT_IMG_VER</span><br></pre></td></tr></table></figure><p>我们创建镜像时使用如下命令，给<code>CONT_IMG_VER</code>传入不同的变量值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker build --build-arg CONT_IMG_VER=v2.0.1 .</span><br></pre></td></tr></table></figure><p>在这种情况下，RUN指令使用v1.0.0而不是用户传递的ARG设置：v2.0.1，就是因为ENV指令定义的环境变量覆盖了同名的ARG变量。</p><p>Docker具有一组预定义的ARG变量，您可以在Dockerfile中使用它们而无需相应的ARG指令:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP_PROXY</span><br><span class="line">http_proxy</span><br><span class="line">HTTPS_PROXY</span><br><span class="line">https_proxy</span><br><span class="line">FTP_PROXY</span><br><span class="line">ftp_proxy</span><br><span class="line">NO_PROXY</span><br><span class="line">no_proxy</span><br></pre></td></tr></table></figure><p>默认情况下，这些预定义变量从Docker历史记录的输出中删除。删除它们可以降低意外泄漏<code>HTTP_PROXY</code>变量中的敏感身份验证信息的风险。如果需要在docker历史记录中输出这些默认变量值，则需要我们在Dockerfile中显示的使用ARG指令指定这个变量。</p><h2 id="14-ONBUILD指令"><a href="#14-ONBUILD指令" class="headerlink" title="14. ONBUILD指令"></a>14. ONBUILD指令</h2><p>当我们的镜像被作为基础镜像执行构建时，此时ONBUILD指令就会生效。其格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ONBUILD [INSTRUCTION]</span><br></pre></td></tr></table></figure><p>运作方式如下：当它遇到<code>ONBUILD</code>指令时，构建器将触发器添加到正在构建的镜像的元数据中，该指令不会影响当前版本。构建结束时，所有触发器的列表都存储在镜像清单中的OnBuild键下。可以使用<code>docker inspect</code>命令查看它们。稍后，可以使用FROM指令将该镜像用作新构建的基础镜像，作为处理FROM指令的一部分，下游构建器将查找ONBUILD触发器，并以与注册时相同的顺序执行它们。如果任何触发器失败，那么FROM指令将中止，从而导致构建失败。如果所有触发器都成功，则FROM指令完成，并且构建照常继续。执行完触发器后，将从最终镜像中清除触发器。换句话说，它们不是<code>孙子代</code>版本所继承的。</p><blockquote><p>❝</p><p><strong>「注意」</strong>：在ONBUILD指令中再指定ONBUILD指令是不允许的，ONBUILD指令可能不会触发FROM或者MAINTAINER指令</p><p>❞</p></blockquote><h2 id="15-STOPSIGNAL指令"><a href="#15-STOPSIGNAL指令" class="headerlink" title="15. STOPSIGNAL指令"></a>15. STOPSIGNAL指令</h2><p><code>STOPSIGNAL</code>指令用来设置系统发送给容器的退出信号，该信号可以是内核syscall表中对应的无符号数字，例如9，也可以是SIGNAME格式的信号名称，例如SIGKILL。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STOPSIGNAL signal</span><br></pre></td></tr></table></figure><h2 id="16-HEALTHCHECK指令"><a href="#16-HEALTHCHECK指令" class="headerlink" title="16. HEALTHCHECK指令"></a>16. HEALTHCHECK指令</h2><p>HEALTHCHECK指令是用来做容器健康检查的，这个指令是在Docker 1.12版本被加入的，在早期版本中并不支持，这个指令可以让我们自定义容器健康状态检查的脚本或者命令。其格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HEALTHCHECK [OPTIONS] CMD command (check container health by running a command inside the container)</span><br><span class="line">HEALTHCHECK NONE (disable any healthcheck inherited from the base image)</span><br></pre></td></tr></table></figure><p>我们为什么需要这样一个指令呢？是因为我们的容器是根据启动命令是否运行来判断容器是否健康的，这就导致一个问题，有时我们的应用程序确实在运行，进程并没有退出，但是此时由于bug或其他原因导致程序已经无法正常对外提供服务，那么此时我们就需要用一个命令或者脚本来检测我们的服务，这就是这个指令存在的意义。</p><p><strong>「HEALTHCHECK指令的OPTIONS字段可以有如下几个选项：」</strong></p><ol><li><code>--interval=DURATION (default: 30s)</code> 健康检测的命令将在容器启动后的DURATION秒后开始第一次运行，然后每隔DURATION秒运行一次，DURATION默认值是30秒;</li><li><code>--timeout=DURATION (default: 30s)</code> 健康检测的命令的超时时间，默认30秒;</li><li><code>--start-period=DURATION (default: 0s)</code> 此选项设置了当容器启动后的DURATION秒后的健康检测如果失败，不计入重试次数，这是为了给容器一个初始化的时间。但是如果这段时间中一旦健康检测为正常，则之后即使在初始化时间内，健康检测如果失败，此时会计入重试次数，默认是0秒;</li><li><code>--retries=N (default: 3)</code> 健康检测的重试次数，重试N次后容器被判断为异常，则退出进程。</li></ol><blockquote><p>❝</p><p><strong>「注意」</strong>：在一个Dockerfile中只能有一个HEALTHCHECK指令，如果指定了多个指令，则只有最后一个指令生效。</p><p>❞</p></blockquote><p>CMD关键字之后的命令可以是shell命令（例如<code>HEALTHCHECK CMD /bin/check-running</code>）或exec数组（与其他Dockerfile命令一样;有关详细信息，请参见ENTRYPOINT）。</p><p><strong>「命令的退出状态指示容器的健康状态。可能的值为：」</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0：success-容器健康且可以使用</span><br><span class="line">1：unhealthy-容器无法正常工作</span><br><span class="line">2：reserved-请勿使用此退出码</span><br></pre></td></tr></table></figure><p>为了调试方便，健康检测的输出会被记录到健康状态内，我们可以通过docker inspect命令去查询，但是当前最多只能存储输出的前4096个字节，所以，健康检测的命令要尽可能简洁。</p><h2 id="17-SHELL指令"><a href="#17-SHELL指令" class="headerlink" title="17. SHELL指令"></a>17. SHELL指令</h2><p>SHELL指令允许覆盖用于命令的shell形式的默认shell。在Linux上，默认shell程序是<code>[&quot;/bin/sh&quot;,&quot;-c&quot;]</code>，在Windows上，默认shell程序是<code>[&quot;cmd&quot;,&quot;/S&quot;,&quot;/C&quot;]</code>。SHELL指令必须使用JSON形式编写。格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL [&quot;executable&quot;, &quot;parameters&quot;]</span><br></pre></td></tr></table></figure><p>SHELL指令可以有多个，每个SHELL指令都会覆盖之前的设置，并且影响其之后的指令。SHELL指令也是在Docker 1.12版本中加入的，所以在更早期的版本中是不支持的。</p><h2 id="18-注意"><a href="#18-注意" class="headerlink" title="18. 注意"></a>18. 注意</h2><p><strong>「很重要:」</strong></p><p>在我们编写Dockerfile时，每一行指令就会生成一个镜像的层，所以，我们应该尽量将相同的操作都写在同一行中，而且我们依然可以使用<code>\</code>来换行，这还是会被当成一层来处理。这样做的好处是可以减小我们的镜像文件的大小，加快容器创建的速度。</p><h1 id="三、构建镜像"><a href="#三、构建镜像" class="headerlink" title="三、构建镜像"></a>三、构建镜像</h1><p>当我们写好了Dockerfile之后，我们就可以使用docker build命令来构建镜像了。命令如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build [OPTIONS] PATH | URL | -</span><br></pre></td></tr></table></figure><p>在构建镜像时，我们可以添加各种参数来定制镜像，还可以直接为镜像打好标签。docker build命令支持的参数详见docker build命令官方文档，在此不再赘述。</p>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dockerfile </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>